<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?07e6d0173d36b52b35d5008d76011f99";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!DOCTYPE html>


<html theme="light" showBanner="true" hasBanner="true" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
<!-- Global site tag (gtag.js) - Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?07e6d0173d36b52b35d5008d76011f99";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- End Baidu Analytics -->


  

  
  <title>前端开发基础 | 云升的小窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="前端基础内容，HTML\CSS\JS三件套。">
<meta property="og:type" content="article">
<meta property="og:title" content="前端开发基础">
<meta property="og:url" content="http://example.com/2024/05/10/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="云升的小窝">
<meta property="og:description" content="前端基础内容，HTML\CSS\JS三件套。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-10T11:32:56.000Z">
<meta property="article:modified_time" content="2024-05-10T11:42:29.578Z">
<meta property="article:author" content="云升">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="云升的小窝" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>
<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>

  
  
    
<div id="banner" class="">
  <img src="/images/background2.jpg" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>云升的小窝 </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/images/avatar.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">云升 </div>
      <div class="dot"></div>
      <div class="subtitle">此心安处是吾乡 </div>
      <div class="link-list">
        
          <a class="link-btn" href="bycj1106@163.com" title="Email"><i class="fa-regular fa-envelope"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://steamcommunity.com/id/bycj/" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/bycj1106" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Categories</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/%E5%BC%80%E5%8F%91/">
                开发
                <div class="category-count">18</div>
            </a>
        
            <a class="category-link" href="/categories/%E5%85%B6%E4%BB%96/">
                其他
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/categories/%E5%B7%A5%E5%85%B7/">
                工具
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/categories/%E7%94%9F%E6%B4%BB/">
                生活
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/%E9%AD%94%E6%9C%AF/">
                魔术
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">
                算法
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/404/" rel="tag">404</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Astro/" rel="tag">Astro</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/CDN/" rel="tag">CDN</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/CMS/" rel="tag">CMS</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/CloudFlare/" rel="tag">CloudFlare</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/DEBUG/" rel="tag">DEBUG</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Erlang/" rel="tag">Erlang</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Swiper/" rel="tag">Swiper</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Twikoo/" rel="tag">Twikoo</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Vue2/" rel="tag">Vue2</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/post/" rel="tag">post</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B/" rel="tag">流程</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83/" rel="tag">环境</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB/" rel="tag">生活</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%BA%B8%E7%89%8C/" rel="tag">纸牌</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%BB%BC%E5%90%88/" rel="tag">综合</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%BE%8E%E5%8C%96/" rel="tag">美化</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/" rel="tag">自定义</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%A1%A8%E6%BC%94/" rel="tag">表演</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%AD%94%E6%9C%AF/" rel="tag">魔术</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Archives</h3>
      
      
        <a class="archive-link" href="/archives/2024/05 ">
          May 2024 
          <div class="archive-count">3 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/04 ">
          April 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/01 ">
          January 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/12 ">
          December 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/11 ">
          November 2023 
          <div class="archive-count">8 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/10 ">
          October 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/09 ">
          September 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/05 ">
          May 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/04 ">
          April 2023 
          <div class="archive-count">9 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Recent Posts</h3>
      <ul>
        
          <a class="recent-link" href="/2024/05/10/CSS%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/" title="CSS技巧笔记" >
            <div class="recent-link-text">
              CSS技巧笔记
            </div>
          </a>
        
          <a class="recent-link" href="/2024/05/10/Swiper11%E5%9C%A8Vue2%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Swiper11在Vue2项目中的使用" >
            <div class="recent-link-text">
              Swiper11在Vue2项目中的使用
            </div>
          </a>
        
          <a class="recent-link" href="/2024/05/10/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" title="前端开发基础" >
            <div class="recent-link-text">
              前端开发基础
            </div>
          </a>
        
          <a class="recent-link" href="/2024/04/13/%E5%9F%BA%E4%BA%8EVue2%E7%9A%84%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Vue2开发学习笔记" >
            <div class="recent-link-text">
              Vue2开发学习笔记
            </div>
          </a>
        
          <a class="recent-link" href="/2024/01/17/Erlang%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Erlang语言基础学习笔记" >
            <div class="recent-link-text">
              Erlang语言基础学习笔记
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-前端开发基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        前端开发基础
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-05-10T11:32:56.000Z" itemprop="datePublished">2024-05-10</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            42k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>申请了招商银行的花嫁储蓄卡，很好看。</p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="语义化-HTML"><a href="#语义化-HTML" class="headerlink" title="语义化 HTML"></a>语义化 HTML</h2><pre><code class="html">1. `
&lt;header&gt;
  `：表示文档的头部区域，通常包含标题、导航链接等内容。 2. `
  &lt;nav&gt;
    `：表示文档的导航区域，通常包含页面内的导航链接。 3. `
    &lt;main&gt;
      `：表示文档的主要内容，一个页面只应包含一个`
      &lt;main&gt;
        `标签。 4. `
        &lt;article&gt;
          `：表示页面中独立的、完整的、可以独立于页面其他内容存在的内容区域，例如一篇博客文章或者一篇新闻报道。
          5. `
          &lt;section&gt;
            `：表示文档中的一个内容区块，比如一章节或者一个标签页。 6. `
            &lt;aside&gt;
              `：表示页面的侧边栏内容，如相关链接、广告、注解等。 7. `
              &lt;footer&gt;
                `：表示文档的尾部，通常包含版权信息、作者信息、联系方式等。 8. `
                &lt;figure&gt;
                  `和`
                  &lt;figcaption&gt;
                    `：分别表示一块包含媒体内容以及该内容的说明文字的区域。 9.
                    `&lt;mark
                      &gt;`：表示需要突出显示的文字。 10. `&lt;time
                        &gt;`：表示时间或日期。 11. `
                        &lt;summary&gt;
                          `和`
                          &lt;details&gt;
                            `：表示一个可以展开和折叠的细节列表。
                          &lt;/details&gt;
                        &lt;/summary&gt;&lt;/time
                      &gt;&lt;/mark
                    &gt;
                  &lt;/figcaption&gt;
                &lt;/figure&gt;
              &lt;/footer&gt;
            &lt;/aside&gt;
          &lt;/section&gt;
        &lt;/article&gt;
      &lt;/main&gt;
    &lt;/main&gt;
  &lt;/nav&gt;
&lt;/header&gt;
</code></pre>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="一般标签"><a href="#一般标签" class="headerlink" title="一般标签"></a>一般标签</h3><pre><code class="html">`&lt;fieldset&gt;`: 框，表单分组。
`&lt;legend&gt;`: 定义&lt;fieldset&gt;的标题。
`&lt;ul&gt;`: 无序列表。CSS中可以通过`list-style-type`来修改列表样式。
`&lt;ol&gt;`: 有序列表。
`&lt;br&gt;`: 换行。
`&lt;textarea&gt;`: 文本区元素。
</code></pre>
<h3 id="lt-input-gt"><a href="#lt-input-gt" class="headerlink" title="&lt;input&gt;"></a><code>&lt;input&gt;</code></h3><pre><code class="html">&lt;!-- 单选框 --&gt;
&lt;input id=&quot;in&quot; type=&quot;radio&quot; name=&quot;radio-1&quot; checked /&gt;
&lt;input id=&quot;out&quot; type=&quot;radio&quot; name=&quot;radio-1&quot; /&gt;
</code></pre>
<p><code>&lt;name&gt;</code>: name 相同的单选框之间相互关联。</p>
<h3 id="lt-label-gt"><a href="#lt-label-gt" class="headerlink" title="&lt;label&gt;"></a><code>&lt;label&gt;</code></h3><p><code>&lt;label&gt;</code> 元素（标签）表示用户界面中某个元素的说明。</p>
<p>将一个 <code>&lt;label&gt;</code> 和一个 <code>&lt;input&gt;</code> 元素相关联主要有这些优点：</p>
<ul>
<li><p>标签文本不仅与其相应的文本输入元素在视觉上相关联，程序中也是如此。这意味着，当用户聚焦到这个表单输入元素时，屏幕阅读器可以读出标签，让使用辅助技术的用户更容易理解应输入什么数据。</p>
</li>
<li><p>可以点击关联的标签来聚焦或者激活这个输入元素，就像直接点击输入元素一样。这扩大了元素的可点击区域，让包括使用触屏设备在内的用户更容易激活这个元素。</p>
</li>
</ul>
<p><strong>使用</strong></p>
<p>将一个 <code>&lt;label&gt;</code> 和一个 <code>&lt;input&gt;</code> 元素匹配在一起，需要给 <code>&lt;input&gt;</code> 一个 <code>id</code> 属性。而 <code>&lt;label&gt;</code> 需要一个 <code>for</code> 属性，其值和 <code>&lt;input&gt;</code> 的 id 一样。</p>
<p>另外，也可以将 <code>&lt;input&gt;</code> 直接放在 <code>&lt;label&gt;</code> 里，此时则不需要 <code>for</code> 和 <code>id</code> 属性，因为关联已隐含存在</p>
<h3 id="lt-span-gt-和-lt-a-gt-的区别"><a href="#lt-span-gt-和-lt-a-gt-的区别" class="headerlink" title="&lt;span&gt;和&lt;a&gt;的区别"></a><code>&lt;span&gt;</code>和<code>&lt;a&gt;</code>的区别</h3><p><code>&lt;span&gt;</code> 和 <code>&lt;p&gt;</code> 标签在 HTML 中分别代表着不同的元素类型，它们的主要区别在于它们的语义含义和呈现方式：</p>
<ol>
<li><p><strong><code>&lt;span&gt;</code></strong></p>
<ul>
<li><strong>语义</strong>：<code>&lt;span&gt;</code> 是一个内联（行内）元素，没有特定的语义含义，主要用于文本的样式标记或者结构划分，尤其在需要对文本中的某个部分进行样式定制时使用。</li>
<li><strong>表现</strong>：<code>&lt;span&gt;</code> 标签不会带来额外的布局效果，不会像块级元素那样独占一行，它所包含的内容将会跟周围的文本一起流动在同一行内，直到遇到换行条件（比如容器边界或者另一个块级元素）才会换行。</li>
<li><strong>使用场合</strong>：常常配合 CSS 进行文本样式控制，例如更改字体颜色、大小、背景等，也可以用于 JavaScript&#x2F;jQuery 等脚本进行动态处理。</li>
</ul>
</li>
<li><p><strong><code>&lt;p&gt;</code></strong></p>
<ul>
<li><strong>语义</strong>：<code>&lt;p&gt;</code> 是一个块级元素，拥有明确的语义，表示一个段落，它意味着一个新的段落开始。</li>
<li><strong>表现</strong>：<code>&lt;p&gt;</code> 标签包裹的内容会自动在其前后生成换行（即段落之间会有一定的垂直间距），并且在标准文档流中，每一个 <code>&lt;p&gt;</code> 元素会另起一行显示。</li>
<li><strong>使用场合</strong>：用来组织文章正文、说明性的文本内容，浏览器会默认为其赋予适当的上下边距（margin），有助于提升阅读体验。</li>
</ul>
</li>
</ol>
<p>总结起来，<code>&lt;span&gt;</code> 主要是用于文本样式控制和结构分割，而 <code>&lt;p&gt;</code> 更注重文本内容的分段显示和文档结构的清晰划分。在 HTML5 语义化编程中，提倡根据内容的逻辑结构选择合适的标签，以便更好地提升 SEO 和辅助技术的理解能力。</p>
<h2 id="表单-form"><a href="#表单-form" class="headerlink" title="表单 form"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">表单 form</a></h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Advanced_form_styling">表单样式化进阶</a></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code class="html">`name`: 表单的名称。HTML 4 中不推荐（应使用 id）。在 HTML 5
中，该值必须是所有表单中独一无二的，而且不能是空字符串。 `autocomplete`:
用于指示 input
元素是否能够拥有一个默认值，此默认值是由浏览器自动补全的。此设定可以被属于此表单的子元素的
autocomplete 属性覆盖。 `action`: 处理表单提交的 URL。这个值可被
&lt;button&gt;
  、&lt;input type=&quot;submit&quot; /&gt; 或 &lt;input type=&quot;image&quot; /&gt; 元素上的 formaction
  属性覆盖。 `method`: 浏览器使用这种 HTTP 方式来提交 表单。可能的值有：
  post：指的是 HTTP POST 方法；表单数据会包含在表单体内然后发送给服务器。
  get：指的是 HTTP GET 方法；表单数据会附加在 action 属性的 URL 中，并以 &#39;?&#39;
  作为分隔符，没有副作用 时使用这个方法。 dialog：如果表单在
  &lt;dialog&gt;
    元素中，提交时关闭对话框。此值可以被
    &lt;button&gt;
      、&lt;input type=&quot;submit&quot; /&gt; 或 &lt;input type=&quot;image&quot; /&gt; 元素中的 formmethod
      属性覆盖。 `novalidate`:
      此布尔值属性表示提交表单时不需要验证表单。如果没有声明该属性（因此表单需要通过验证）。该属性可以被表单中的
      &lt;button&gt;
        、&lt;input type=&quot;submit&quot; /&gt; 或 &lt;input type=&quot;image&quot; /&gt; 元素中的
        formnovalidate 属性覆盖。
      &lt;/button&gt;
    &lt;/button&gt;
  &lt;/dialog&gt;
&lt;/button&gt;
</code></pre>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>CSS 选择器是 CSS 语言中用于定位 HTML 文档中需要设置样式的元素的一种机制。它们就像一把钥匙，帮助开发者锁定并应用样式到特定的 HTML 元素上。选择器允许根据元素的名称、属性、类名、ID 以及其他特性来精确指定元素，以便为这些元素设置样式。</p>
<p><strong>CSS 三种引入方式的使用方法和优缺点</strong></p>
<ol>
<li><p><strong>内联样式（Inline Styles）</strong></p>
<ul>
<li><p><strong>使用方法</strong>：<br>在 HTML 标签内部使用 <code>style</code> 属性来定义样式，例如：</p>
<pre><code class="html">&lt;p style=&quot;color: red; font-size: 16px;&quot;&gt;这是一个段落&lt;/p&gt;
</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>最直接且高效，样式会立即应用到指定元素上，无需额外的 HTTP 请求。</li>
<li>权重较高，内联样式优先级高于外部样式表和内部样式表。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>不利于代码复用和组织，增加页面体积，使得 HTML 和 CSS 紧密耦合，违反了内容与表现分离的原则。</li>
<li>不便于维护，特别是当需要在整个网站范围内修改样式时，需要逐个修改每个含有内联样式的元素。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内部样式表（Internal Stylesheet）</strong></p>
<ul>
<li><p><strong>使用方法</strong>：<br>在 HTML 文档的 <code>&lt;head&gt;</code> 标签内使用 <code>&lt;style&gt;</code> 标签来编写样式，例如：</p>
<pre><code class="html">&lt;head&gt;
  &lt;style&gt;
    p &#123;
      color: blue;
      font-size: 14px;
    &#125;
  &lt;/style&gt;
&lt;/head&gt;
</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>相对于内联样式，内部样式表适用于应用于整个文档的样式规则，有助于减少代码重复。</li>
<li>仍然位于同一个文件内，相对简单且易于理解。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>仍不具备良好的代码复用性和模块化能力，多个 HTML 文件需共享样式时，需要在每个文件中复制内部样式表，增加维护成本。</li>
<li>不利于组件化开发和样式隔离，多个页面间的样式难以独立管理和更新。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>外部样式表（External Stylesheet）</strong></p>
<ul>
<li><p><strong>使用方法</strong>：<br>在 HTML 文档中通过 <code>&lt;link&gt;</code> 标签引用外部 CSS 文件，例如：</p>
<pre><code class="html">&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; /&gt;
&lt;/head&gt;
</code></pre>
<p>然后在 <code>styles.css</code> 文件中编写样式：</p>
<pre><code class="css">p &#123;
  color: green;
  font-size: 16px;
&#125;
</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>易于维护和更新，一个 CSS 文件可以服务于多个 HTML 文件，有利于代码复用和模块化。</li>
<li>实现内容与表现的完美分离，有利于 SEO 优化和页面加载性能（通过缓存机制）。</li>
<li>可以更好地组织和分类样式，方便多人协作开发。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>需要额外的 HTTP 请求，首次加载页面时可能会影响速度，但如果合理利用缓存，则长期来看反而能提升性能。</li>
<li>控制权相对较弱，浏览器会按照 CSS 文件的顺序和层叠规则决定最终样式，调试时不如内联样式直观。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Fundamentals">文字</a></h2><p><a target="_blank" rel="noopener" href="https://html-css-js.com/css/generator/font/">文字样式在线测试网站</a></p>
<h3 id="italic和oblique的区别"><a href="#italic和oblique的区别" class="headerlink" title="italic和oblique的区别"></a><code>italic</code>和<code>oblique</code>的区别</h3><p><code>font-style</code> 非常简单：用于在 <code>normal</code> 文本、<code>italic</code> 文本和 <code>oblique</code> 文本之间选择。唯一有点复杂的是明确 <code>italic</code> 文本和 <code>oblique</code> 文本之间的差别。</p>
<p>斜体（italic）是一种简单的字体风格，对每个字母的结构有一些小改动，来反映变化的外观。与此不同，倾斜（oblique）文本则是正常竖直文本的一个倾斜版本。</p>
<p>通常情况下，italic 和 oblique 文本在 web 浏览器中看上去完全一样。</p>
<h3 id="text-transform和font-variant的区别"><a href="#text-transform和font-variant的区别" class="headerlink" title="text-transform和font-variant的区别"></a><code>text-transform</code>和<code>font-variant</code>的区别</h3><p><code>text-transform</code> 和 <code>font-variant</code> 是 CSS 中用于改变文本样式的两个不同属性，它们的主要区别在于作用的对象和方式不同。</p>
<p>**<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-transform">text-transform</a>**：</p>
<ul>
<li>该属性用于控制文本的大小写形式，它不影响文本的实际字体或字形，而是对文本内容进行转换。</li>
<li>支持的值包括：<ul>
<li><code>none</code>（默认值）：不做大小写转换。</li>
<li><code>capitalize</code>：每个单词的首字母转为大写，其余字母保持原样。</li>
<li><code>uppercase</code>：将所有文本转换为大写。</li>
<li><code>lowercase</code>：将所有文本转换为小写。</li>
<li><code>full-width</code>：将文本转换为全角字符（仅在支持东亚文字的环境下有意义）。</li>
</ul>
</li>
</ul>
<p>**<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant">font-variant</a>**：</p>
<ul>
<li>主要用于控制文本的排版变化，特别是在西方字体中，它能够启用一些特殊的设计变体，如小型大写字母（Small Caps）。</li>
<li>传统上，<code>font-variant</code> 的常见用法是：<ul>
<li><code>normal</code>（默认值）：使用标准字体样式。</li>
<li><code>small-caps</code>：将文本转换为小型大写字母，这是一种特殊的字体设计，其中小写字母被替换为其大写的缩小版，通常用于强调或排版样式。</li>
</ul>
</li>
</ul>
<p>在 CSS3 以后，<code>font-variant</code>属性得到了扩展，可以用于控制更多类型的字形变化，例如连字符、数字的斜体&#x2F;衬线等。例如：</p>
<ul>
<li><code>font-variant-ligatures</code>：控制连字符的使用。</li>
<li><code>font-variant-position</code>：控制上标和下标的定位。</li>
<li><code>font-variant-caps</code>：除了<code>small-caps</code>之外，还包括更多类型的大小写变换选项，如全大写、全小写、Petite Capitals 等。</li>
<li><code>font-variant-numeric</code>：控制数字、小数点和分数的样式。</li>
<li><code>font-variant-alternates</code>：控制字体中的替代字形。</li>
</ul>
<p>总结起来，<code>text-transform</code>侧重于大小写转换，而<code>font-variant</code>更关注字体自身的变体和特殊样式。</p>
<h2 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Backgrounds_and_borders#css%E7%9A%84%E8%83%8C%E6%99%AF%E6%A0%B7%E5%BC%8F">背景与边框</a></h2><p>在 CSS 中，背景（Background）和边框（Border）是用于装饰元素外观的重要属性。以下是对这两个属性的基本介绍和常用属性说明：</p>
<p><strong>背景（Background）</strong>：<br>背景属性用于设置元素背后的区域样式，包括颜色、图像、重复模式等。</p>
<p>常用背景属性包括：</p>
<ul>
<li><code>background-color</code>: 设置元素的背景颜色。<pre><code class="css">element &#123;
  background-color: red;
&#125;
</code></pre>
</li>
<li><code>background-image</code>: 设置背景图片。<pre><code class="css">element &#123;
  background-image: url(&quot;image.jpg&quot;);
&#125;
</code></pre>
</li>
<li><code>background-repeat</code>: 设置背景图片是否及如何重复，可选值有 <code>repeat</code>（默认，水平垂直重复）、<code>repeat-x</code>、<code>repeat-y</code>、<code>no-repeat</code>。<pre><code class="css">element &#123;
  background-repeat: no-repeat;
&#125;
</code></pre>
</li>
<li><code>background-size</code>: 设置背景图片的大小，可以是绝对单位或相对单位，也可使用关键词 <code>contain</code> 或 <code>cover</code>。<pre><code class="css">element &#123;
  background-size: cover;
&#125;
</code></pre>
</li>
<li><code>background-position</code>: 设置背景图片在元素内的位置。<pre><code class="css">element &#123;
  background-position: center;
&#125;
</code></pre>
</li>
<li><code>background-attachment</code>: 设置背景图片相对于视口的滚动行为，可选值有 <code>scroll</code>（默认，随内容滚动）、<code>fixed</code>（固定在视口）和 <code>local</code>（随元素内容滚动）。<pre><code class="css">element &#123;
  background-attachment: fixed;
&#125;
</code></pre>
</li>
<li>为了简化书写，以上所有属性可以合并写在一个 <code>background</code> 短语中：<pre><code class="css">element &#123;
  background: #ff0000 url(&quot;image.jpg&quot;) no-repeat center / cover fixed;
&#125;
</code></pre>
</li>
</ul>
<p><strong>边框（Border）</strong>：<br>边框属性用于设置元素周围的线条样式，包括宽度、样式、颜色等。</p>
<p>常用边框属性包括：</p>
<ul>
<li><code>border-width</code>: 设置边框的宽度。<pre><code class="css">element &#123;
  border-width: 1px;
&#125;
</code></pre>
</li>
<li><code>border-style</code>: 设置边框的样式，如 <code>solid</code>（实线，默认）、<code>dotted</code>（点线）、<code>dashed</code>（虚线）、<code>double</code>（双线）等。<pre><code class="css">element &#123;
  border-style: dotted;
&#125;
</code></pre>
</li>
<li><code>border-color</code>: 设置边框的颜色。<pre><code class="css">element &#123;
  border-color: blue;
&#125;
</code></pre>
</li>
<li>同样的，这三个属性也可以合并成一个简写属性 <code>border</code> 来一起设置：<pre><code class="css">element &#123;
  border: 1px solid blue;
&#125;
</code></pre>
</li>
<li>另外，可以分别针对上、右、下、左边框设置不同的宽度、样式和颜色，例如：<pre><code class="css">element &#123;
  border-top: 1px solid red;
  border-right: 2px dashed green;
  border-bottom: 3px double blue;
  border-left: 4px dotted black;
&#125;
</code></pre>
</li>
<li>还可以分别为四个角设置圆角半径，使用 <code>border-radius</code> 属性：<pre><code class="css">element &#123;
  border-radius: 10px; /* 四个角都有相同的圆角 */
  border-top-left-radius: 20px; /* 左上角单独设置圆角 */
&#125;
</code></pre>
</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors">选择器</a></h2><h3 id="层叠、优先级与继承"><a href="#层叠、优先级与继承" class="headerlink" title="层叠、优先级与继承"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance">层叠、优先级与继承</a></h3><p>在 CSS 中，层叠、优先级和继承是三个核心概念，它们共同决定了样式在网页中的应用方式：</p>
<ol>
<li><p><strong>层叠（Cascading）</strong>：<br>层叠是指多个 CSS 规则可能同时影响一个 HTML 元素，CSS 通过一套规则决定哪些样式最终应用于元素。层叠的核心思想是，当有多个选择器都定义了同一属性时，CSS 会依据一定的规则决定最终使用的样式。这些规则包括：来源（如内联样式、内部样式表、外部样式表的优先级）、特异性（选择器的复杂程度和匹配度）以及样式声明的顺序（当特异性相同时，后声明的样式覆盖之前的样式）。</p>
</li>
<li><p><strong>优先级（Specificity）</strong>：<br>CSS 选择器的优先级是由其组成成分决定的。优先级从高到低大致排序为：</p>
<ul>
<li>内联样式（如 <code>style</code> 属性）</li>
<li>ID 选择器（如 <code>#myID</code>）</li>
<li>类选择器、属性选择器、伪类选择器（如 <code>.myClass</code>、<code>[attribute]</code>、<code>:hover</code>)</li>
<li>元素和伪元素选择器（如 <code>div</code>、<code>:before</code>）</li>
<li>通用选择器（如 <code>*</code>）<br>当两个或更多选择器都定义了同一个属性时，具有更高优先级的选择器将决定元素的样式。优先级可以通过计算选择器中 ID 选择器数量、类选择器数量、属性选择器数量和其他类型选择器数量得出。</li>
</ul>
</li>
<li><p><strong>继承（Inheritance）</strong>：<br>继承指的是子元素可以获取父元素的一些 CSS 属性值。不是所有的 CSS 属性都可以被继承，例如文本相关的属性（如颜色、字体大小）通常是可以被继承的，而盒模型相关的属性（如边距、填充、边框）则是不能被继承的。如果一个元素没有自己定义某个可继承属性，它会沿用父元素的该属性值。如果子元素自己定义了该属性，则不再继承父元素的值。</p>
</li>
</ol>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">属性选择器</a></h3><p>属性选择器是一种强大的 CSS 选择器，可以根据 HTML 元素的属性及属性值来选取元素。属性选择器允许开发者定位具有特定属性或特定属性值的 HTML 元素，极大地提高了 CSS 样式的针对性和灵活性。以下是一些常见的属性选择器类型：</p>
<ol>
<li><p>**存在属性选择器 (<code>[attr]</code>)**：<br>选择具有指定属性（attr）的任何元素，不论属性值为何。</p>
<pre><code class="css">[title] &#123;
  color: red;
&#125;
</code></pre>
<p>上述代码将选择所有带有<code>title</code>属性的元素，并将其文本颜色设置为红色。</p>
</li>
<li><p>**等于属性值选择器 (<code>[attr=val]</code>)**：<br>选择具有指定属性（attr），且属性值完全等于指定值（val）的元素。</p>
<pre><code class="css">input[type=&quot;text&quot;] &#123;
  width: 100%;
&#125;
</code></pre>
<p>此代码将选择所有<code>type</code>属性值为<code>text</code>的<code>input</code>元素，并将其宽度设置为 100%。</p>
</li>
<li><p>**开头包含值选择器 (<code>[attr^=val]</code>)**：<br>选择具有指定属性（attr），且属性值以指定值（val）开头的元素。</p>
<pre><code class="css">a[href^=&quot;https://&quot;]
&#123;
  color: blue;
&#125;
</code></pre>
<p>该代码将选择所有<code>href</code>属性值以<code>https://</code>开头的<code>a</code>元素，并将其链接颜色设置为蓝色。</p>
</li>
<li><p>**结尾包含值选择器 (<code>[attr$=val]</code>)**：<br>选择具有指定属性（attr），且属性值以指定值（val）结尾的元素。</p>
<pre><code class="css">img[src$=&quot;.png&quot;] &#123;
  border: 1px solid black;
&#125;
</code></pre>
<p>该代码将选择所有<code>src</code>属性值以<code>.png</code>结尾的<code>img</code>元素，并为其添加 1 像素黑色边框。</p>
</li>
<li><p>**包含值选择器 (<code>[attr*=val]</code>)**：<br>选择具有指定属性（attr），且属性值中包含指定值（val）的元素。</p>
<pre><code class="css">div[class*=&quot;container&quot;] &#123;
  width: 100%;
&#125;
</code></pre>
<p>该代码将选择所有<code>class</code>属性值中包含<code>container</code>的<code>div</code>元素，并将其宽度设为 100%。</p>
</li>
<li><p>**属性值列表中的子串匹配选择器 (<code>[attr~=val]</code>)**：<br>选择具有指定属性（attr），且属性值是一个以空格分隔的值列表，其中包含指定值（val）的元素。</p>
<pre><code class="css">li[data-tags~=&quot;important&quot;] &#123;
  font-weight: bold;
&#125;
</code></pre>
<p>该代码将选择所有<code>data-tags</code>属性值中包含<code>important</code>的<code>li</code>元素，并使其文本加粗。</p>
</li>
</ol>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements">伪类和伪元素</a></h3><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是使文档的某个部分应用了一个类一样，可以在标记文本中减少多余的类，让代码更灵活、更易于维护。</p>
<p>伪类就是开头为冒号的关键字：</p>
<p><code>:pseudo-class-name</code></p>
<pre><code class="css">/* 简单伪类 */
:first-child 一直选中兄弟元素中的第一个子元素。
:last-child 一直选中兄弟元素中的最后一个子元素。
:only-child 一直选中没有任何兄弟元素的元素。
:invalid 用来选择任何未通过验证的 &lt;form&gt;、&lt;fieldset&gt;、&lt;input&gt; 或其他表单元素,一般用来突出显示用户输入的字段错误。
:active 在用户激活（例如点击）元素的时候匹配。
:nth-of-type() 匹配某种类型的一列兄弟元素。
:read-only 匹配用户不可更改的元素。
/* 用户行为伪类 */
:hover 在用户使用指针设备与元素进行交互时匹配，但不一定激活它。通常情况下，用户将光标（鼠标指针）悬停在元素上时触发。
:focus 表示获得焦点的元素（如表单输入）。当用户点击或轻触一个元素或使用键盘的Tab键选择它时，它会被触发。
</code></pre>
<h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>伪元素以类似方式表现，不过表现得是像是往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::。</p>
<pre><code class="css">::first-line 选中第一行。
::first-letter 匹配元素的第一个字母。
::selection 匹配文档中被选择的部分。
/* ::before和::after伪元素与content属性的共同使用，在 CSS 中被叫做“生成内容” */
::before 在元素之前。
::after 在元素之后。
</code></pre>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">盒模型</a></h2><p>盒模型（Box Model）是 CSS 中用于描述网页元素布局的一种逻辑结构模型，它定义了一个 HTML 元素的布局和尺寸计算方式。每个 HTML 元素都被视为一个矩形的盒子，该盒子由以下几个部分构成：</p>
<ol>
<li><p><strong>内容区（Content）</strong>：<br>这是元素的实际内容区域，包括文本、图片等。设置元素的 <code>width</code> 和 <code>height</code> 属性就是指内容区的尺寸。</p>
</li>
<li><p><strong>内边距（Padding）</strong>：<br>内边距是围绕内容区的空白区域，用于增加元素内容与边框之间的距离。可以通过 <code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code> 和 <code>padding-left</code> 分别设置各边的内边距，或者使用 <code>padding</code> 简写属性一次性设置所有内边距。</p>
</li>
<li><p><strong>边框（Border）</strong>：<br>边框包裹在内边距外面，为元素添加可视的轮廓。边框的宽度、样式（实线、虚线、点线等）和颜色可以通过 <code>border-width</code>、<code>border-style</code> 和 <code>border-color</code> 分别设置，也可以使用 <code>border</code> 简写属性一次性设置所有边框属性。</p>
</li>
<li><p><strong>外边距（Margin）</strong>：<br>外边距是盒子边缘与其它盒子之间的空白区域，用于控制元素之间的间距。外边距与内边距类似，可以通过 <code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code> 和 <code>margin-left</code> 分别设置各边的外边距，也可以使用 <code>margin</code> 简写属性设置。</p>
</li>
</ol>
<p>在 CSS 中，有两种盒模型计算方式：</p>
<ul>
<li><p><strong>标准盒模型（W3C 盒模型）</strong>：<br>元素总宽度和总高度由内容区宽度（<code>width</code>）和高度（<code>height</code>）、内边距（<code>padding</code>）、边框（<code>border</code>）以及外边距（<code>margin</code>）共同组成。即 <code>总宽度 = 内容区宽度 + 左右内边距 + 左右边框宽度 + 左右边距</code>，<code>总高度</code> 计算方式类似。</p>
</li>
<li><p><strong>IE 盒模型（怪异盒模型）</strong>：<br>在 IE 盒模型中，元素的 <code>width</code> 和 <code>height</code> 包含了内容区和内边距，而不包括边框和外边距。若要得到与标准盒模型同样的视觉效果，需要手动减去内边距和边框的宽度或高度。</p>
</li>
</ul>
<p>为了控制盒模型的计算方式，可以使用 <code>box-sizing</code> 属性，取值有 <code>content-box</code>（标准盒模型）和 <code>border-box</code>（IE 盒模型）。默认情况下，大部分浏览器遵循标准盒模型，但早期的 IE 浏览器默认使用的是怪异盒模型。</p>
<p><strong>外部显示类型</strong></p>
<p>一个拥有 <code>block</code> 外部显示类型的盒子会表现出以下行为：</p>
<p>盒子会产生换行。<br><code>width</code> 和 <code>height</code> 属性可以发挥作用。<br>内边距、外边距和边框会将其他元素从当前盒子周围“推开”。<br>如果未指定 <code>width</code>，方框将沿行向扩展，以填充其容器中的可用空间。在大多数情况下，盒子会变得与其容器一样宽，占据可用空间的 100%。<br>某些 HTML 元素，如 <code>&lt;h1&gt;</code> 和 <code>&lt;p&gt;</code>，默认使用 <code>block</code> 作为外部显示类型。</p>
<p>一个拥有 <code>inline</code> 外部显示类型的盒子会表现出以下行为：</p>
<p>盒子不会产生换行。<br><code>width</code> 和 <code>height</code> 属性将不起作用。<br>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。<br>水平方向的内边距、外边距以及边框会被应用且会把其他处于 <code>inline</code> 状态的盒子推开。<br>某些 HTML 元素，如 <code>&lt;a&gt;</code>、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code>，默认使用 <code>inline</code> 作为外部显示类型。</p>
<p><strong>内部显示类型</strong></p>
<p>区块和行内布局是网络上的默认行为方式。默认情况下，在没有任何其他指令的情况下，方框内的元素也会以标准流的方式布局，并表现为区块或行内盒子。</p>
<p>例如，可以通过设置 <code>display: flex</code>; 来更改内部显示类型。该元素仍将使用外部显示类型 <code>block</code> 但内部显示类型将变为 <code>flex</code>。</p>
<p><code>display</code>属性设置元素是否被视为块或者内联元素以及用于子元素的布局，例如流式布局、网格布局或弹性布局。</p>
<pre><code class="css">/* display的一些属性值 */
/* 外部表现 */
block
    该元素生成一个块级元素盒，在正常的流中，该元素之前和之后产生换行。
inline
    该元素生成一个或多个内联元素盒，它们之前或者之后并不会产生换行。在正常的流中，如果有空间，下一个元素将会在同一行上。
/* 浏览器支持双值语法，当仅发现外部值时，例如当指定 display: block 或 display: inline，其将内部值设置为 flow。这种行为是预期的；例如，如果你指定一个元素是块元素，你将期望该元素的子元素将同块和内联元素一样参与正常的流布局。 */
display: block flow;
/* 内部表现 */
flow
    该元素使用流式布局（块和内联布局）来排布它的内容。如果它的外部显示类型是 inline 或 run-in，并且它参与一个块或者内联格式上下文，那么它将生成一个内联盒子。否则它将生成一个块容器盒。
flow-root
    该元素生成一个块级元素盒，其会建立一个新的区块格式化上下文，定义格式化上下文的根元素。
table
    该元素的行为类似块级元素并且根据弹性盒模型布局它的内容。
flex
    该元素的行为类似块级元素并且根据弹性盒模型布局它的内容。
grid
    该元素的行为类似块级元素并且根据网格模型布局它的内容。
</code></pre>
<h3 id="弹性盒子布局-flex"><a href="#弹性盒子布局-flex" class="headerlink" title="弹性盒子布局(flex)"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout">弹性盒子布局(flex)</a></h3><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a></p>
<p>CSS 弹性盒子布局是 CSS 的模块之一，定义了一种针对用户界面设计而优化的 CSS 盒子模型。在弹性布局模型中，弹性容器的子元素可以在任何方向上排布，也可以“弹性伸缩”其尺寸，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免父元素溢出。子元素的水平对齐和垂直对齐都能很方便的进行操控。通过嵌套这些框（水平框在垂直框内，或垂直框在水平框内）可以在两个维度上构建布局。</p>
<h4 id="flex-布局的基本概念"><a href="#flex-布局的基本概念" class="headerlink" title="flex 布局的基本概念"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox">flex 布局的基本概念</a></h4><p>由于所有 CSS 属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：</p>
<ul>
<li>元素排列为一行（flex-direction 属性的初始值是 row）。</li>
<li>元素从主轴的起始线开始。</li>
<li>元素不会在主维度方向拉伸，但是可以缩小。</li>
<li>元素被拉伸来填充交叉轴大小。</li>
<li>flex-basis 属性为 auto。</li>
<li>flex-wrap 属性为 nowrap。</li>
</ul>
<p>这会让你的元素呈线形排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而不会换行。如果一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。</p>
<h4 id="flex-的两条轴线"><a href="#flex-的两条轴线" class="headerlink" title="flex 的两条轴线"></a>flex 的两条轴线</h4><p>当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴,交叉轴垂直于主轴。</p>
<p>主轴由<code>flex-direction</code>定义，可以取 4 个值：</p>
<pre><code class="css">/* row或row-reverse，主轴将沿着行向延伸。 */
row
row-reverse
/* column或column-reverse，主轴会沿着页面的上下方向延伸——也就是块向。 */
column
column-reverse
</code></pre>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p><code>flex-wrap</code>属性指定<code>flex</code>元素单行显示还是多行显示。如果允许换行，这个属性允许你控制行的堆叠方向。</p>
<p>由于<code>flex-wrap</code>的值设置为<code>wrap</code>，所以项目的子元素换行显示。若将其设置为<code>nowrap</code>，这也是初始值，它们将会缩小以适应容器，因为它们使用的是允许缩小的初始<code>Flexbox</code>值。如果项目的子元素无法缩小，使用<code>nowrap</code>会导致溢出，或者缩小程度还不够小。</p>
<h4 id="对齐属性"><a href="#对齐属性" class="headerlink" title="对齐属性"></a>对齐属性</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items">align-item</a>: 竖直方向对齐方式。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content">justify-content</a>: 水平方向对齐方式。</p>
<!-- flex: 1; ?? -->

<h4 id="经典用例"><a href="#经典用例" class="headerlink" title="经典用例"></a>经典用例</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Typical_use_cases_of_flexbox">弹性盒子的典型用例</a></p>
<h3 id="浮动和清除浮动"><a href="#浮动和清除浮动" class="headerlink" title="浮动和清除浮动"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">浮动和清除浮动</a></h3><p>CSS 中的浮动（Float）和清除浮动（Clearing Floats）是布局设计中非常重要的概念，主要用于定位元素和构建多列布局等场景。</p>
<p><strong>浮动（Float）</strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/play">示例</a></p>
<p>浮动是一种样式属性，通过设置 <code>float</code> 属性可以使元素从正常的文档流（normal flow）中脱离出来，按照指定的方向移动，直到它的外边缘碰到包含框或者其他浮动元素的边缘为止。常见的浮动方向有两个：</p>
<ul>
<li><code>float: left;</code>：元素会尽可能向其容器的左侧靠拢，并让右侧的内容环绕它。</li>
<li><code>float: right;</code>：元素会尽可能向其容器的右侧靠拢，并让左侧的内容环绕它。</li>
</ul>
<p>浮动的一个常见用途是实现图像与文本环绕效果，但更多时候被用来构建多列布局，比如创建水平布局的导航菜单或其他并排显示的区块。</p>
<p><strong>清除浮动（Clearing Floats）</strong></p>
<p>当一个元素浮动后，它会导致其后的兄弟元素跟随其浮动，除非这些元素也设置了浮动属性。然而，这可能导致一些布局问题，如父容器高度坍塌（因为浮动元素不在文档流中，所以父容器可能无法感知其高度，表现为高度为 0），进而影响后续内容的布局。</p>
<p>为了处理这个问题，可以使用 <code>clear</code> 属性来清除浮动。常用的清除浮动方法有：</p>
<ul>
<li><code>clear: both;</code>：不允许元素的左边和右边有任何浮动元素。</li>
<li><code>clear: left;</code>：元素的左边不允许有浮动元素。</li>
<li><code>clear: right;</code>：元素的右边不允许有浮动元素。</li>
</ul>
<p><strong><em>清除浮动的常用技巧：</em></strong></p>
<ol>
<li><p><strong>添加清浮动元素</strong>：<br>在浮动元素后面添加一个空的 <code>&lt;div&gt;</code>，并设置 <code>clear: both;</code>，然后隐藏这个空元素（例如：<code>.clearfix &#123; clear: both; &#125;</code> 或 <code>.clearfix::before, .clearfix::after &#123; content: &quot;&quot;; display: table; clear: both; &#125;</code> 使用伪元素清除浮动）。</p>
</li>
<li><p><strong>父元素 overflow 属性</strong>：<br>给浮动元素的父元素设置 <code>overflow</code> 属性为 <code>auto</code> 或 <code>hidden</code>，这样可以触发 BFC（块格式化上下文），从而包含浮动元素，计算出正确的高度。</p>
</li>
<li><p><strong>使用 Flexbox 或 Grid Layout</strong>：<br>在现代布局中，可以通过 Flexbox 或 Grid 布局体系来替代浮动进行更灵活和直观的布局设计，避免了浮动带来的许多问题。</p>
</li>
<li><p><strong>CSS Grid</strong>：<br>使用 CSS Grid 布局时，由于其天然的二维布局能力，通常不需要浮动来进行布局。</p>
</li>
</ol>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing">box-sizing</a></h3><p><code>content-box</code> 是默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</p>
<p><code>border-box</code> 告诉浏览器：你想要设置的边框和内边距的值是包含在 <code>width</code> 内的。也就是说，如果你将一个元素的 <code>width</code> 设为 100px，那么这 100px 会包含它的 <code>border</code> 和 <code>padding</code>，内容区的实际宽度是 <code>width</code> 减去 (<code>border</code> + <code>padding</code>) 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning">定位</a></h2><p>CSS 中的定位（Positioning）是指通过 CSS 的<code>position</code>属性来控制元素在页面中的布局位置。<code>position</code>属性有五个可选值：<code>static</code>（默认值）、<code>relative</code>、<code>absolute</code>、<code>fixed</code>和<code>sticky</code>。</p>
<ol>
<li><p><strong>static</strong>：<br>默认定位方式，元素遵循正常的文档流（Normal Flow），<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>属性无效。</p>
</li>
<li><p><strong>relative</strong>：<br>相对定位，元素相对于其正常文档流（Static Position）的位置进行偏移。元素保持在文档流中原来的位置，但它周围的空间（原本占用的位置）仍然保留。可以使用<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>属性来设置偏移量。</p>
</li>
<li><p><strong>absolute</strong>：<br>绝对定位，元素脱离文档流，相对于最近的非<code>static</code>定位的祖先元素进行定位。如果这样的祖先元素不存在，则相对于初始包含块（如<body>或<html>）进行定位。使用<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>属性设置其相对于定位上下文的位置。</p>
</li>
<li><p><strong>fixed</strong>：<br>固定定位，元素脱离文档流，相对于浏览器窗口进行定位，即使页面滚动，元素的位置也会保持不变。同样使用<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>属性来设置其相对于浏览器窗口的位置。</p>
</li>
<li><p><strong>sticky</strong>：<br>粘性定位，元素在正常文档流中按照常规流进行定位，直到遇到指定阈值（如到达视窗顶部或底部）时，才转变为相对于视窗定位，固定在某个位置。粘性定位的元素总是相对于其最近的非<code>static</code>定位祖先进行偏移，而非浏览器窗口。</p>
</li>
</ol>
<p>定位属性配合<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>属性可以帮助开发者灵活地控制元素在页面中的布局，实现复杂的界面设计和响应式布局。</p>
<h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Responsive_Design">响应式设计</a></h2><p><a target="_blank" rel="noopener" href="https://www.imooc.com/learn/1285">视频</a></p>
<p><strong><em><a target="_blank" rel="noopener" href="https://www.cnblogs.com/refe/p/5036117.html">手机&#x2F;移动前端开发</a></em></strong></p>
<p>响应式设计（Responsive Design）是一种网页设计策略，它使得网页能够根据访问设备（如桌面电脑、平板电脑、智能手机或智能电视等）的屏幕尺寸、方向和分辨率进行自适应调整，从而提供最佳的用户体验。这种设计方法确保了网站在各种不同大小和形状的屏幕上都能美观且易读，无论用户是通过什么设备访问网站。</p>
<p>响应式设计的基本原理和实践方法包括：</p>
<ol>
<li><p><strong>媒体查询（Media Queries）</strong>：<br>使用 CSS3 的媒体查询，可以针对不同的设备视窗尺寸定义不同的 CSS 样式。例如，当屏幕宽度小于一定值时，可以调整布局，隐藏某些内容或改变字体大小。</p>
</li>
<li><p><strong>弹性网格布局（Flexible Grid）</strong>：<br>设计时采用百分比或弹性单位（如 rem、em）代替固定的像素值，使得布局可以随着窗口大小变化而伸缩。</p>
</li>
<li><p><strong>可伸缩图片（Responsive Images）</strong>：<br>图片的尺寸可以根据屏幕大小自动调整，例如使用<code>max-width: 100%; height: auto;</code>来确保图片不会超出其容器，并按比例缩放。</p>
</li>
<li><p><strong>可伸缩字体（Fluid Typography）</strong>：<br>字体大小也可能是相对的，基于视口宽度进行调整，确保在不同尺寸的屏幕上保持可读性。</p>
</li>
<li><p><strong>适应性导航菜单（Adaptive Navigation Menus）</strong>：<br>对于小屏幕设备，导航菜单可能会变成下拉列表或者汉堡菜单，以节省空间。</p>
</li>
</ol>
<p>响应式设计的目标是创建一种无缝的用户体验，无论用户是在哪种设备上浏览网站，都能轻松访问内容和功能，并保持一致性。它已成为现代网页设计的标准实践，特别是在移动优先和跨平台兼容性越来越重要的今天。</p>
<p><strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">响应式图片</a></strong></p>
<h3 id="媒体查询-media"><a href="#媒体查询-media" class="headerlink" title="媒体查询@media"></a>媒体查询<code>@media</code></h3><p><code>@media</code> 是 CSS 中的一个重要特性，用于定义针对不同媒体类型和条件的样式规则。通过 <code>@media</code> 查询，开发者可以根据设备视窗尺寸、设备分辨率、设备类型等因素为不同的设备环境提供定制化的样式。</p>
<p>基本语法格式如下：</p>
<pre><code class="css">@media media_query &#123;
    /* 在满足媒体查询条件时应用的样式 */
    style_rules...
&#125;
</code></pre>
<p>这里的 <code>media_query</code> 是一组媒体特性表达式，例如：</p>
<pre><code class="css">@media screen and (min-width: 768px) &#123;
  body &#123;
    background-color: lightblue;
  &#125;
&#125;

/* 或者 */

@media print &#123;
  body &#123;
    font-size: 10pt;
  &#125;
&#125;
</code></pre>
<ul>
<li>第一个示例表明当屏幕的最小宽度为 768 像素时，body 的背景颜色变为浅蓝色。</li>
<li>第二个示例则是在打印文档时应用样式，将 body 的字体大小设置为 10pt。</li>
</ul>
<p><code>@media</code> 查询广泛应用于响应式网页设计（Responsive Web Design, RWD），根据设备特性调整布局、颜色、字体大小等，以优化不同设备（如桌面电脑、平板、手机等）上的用户体验。</p>
<h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><p>除非使用 <code>not</code> 或 <code>only</code> 逻辑运算符，否则媒体类型是可选的，并且会（隐式地）应用 <code>all</code> 类型。</p>
<p><code>all</code> - 适用于所有设备。</p>
<p><code>print</code> - 适用于在打印预览模式下在屏幕上查看的分页材料和文档。</p>
<p><code>screen</code> - 主要用于屏幕。</p>
<h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">网格布局</a></h3><p>网格布局（Grid Layout）是 CSS3 中的一项高级布局模块，旨在提供一种强大的二维布局系统，以创建复杂、响应式的网页布局。通过网格布局，开发者可以将容器划分为一系列行和列组成的网格，并灵活地定位和调整其内部元素的大小和位置。</p>
<p>在 CSS 中，使用 <code>display: grid;</code> 将一个容器元素声明为网格容器，然后可以定义以下属性来创建和控制网格：</p>
<ul>
<li><p><strong>grid-template-columns</strong> 和 <strong>grid-template-rows</strong>：用于定义网格的列和行轨道（track）的大小。可以使用长度值、百分比、fr 单位（fractional unit，用于分配可用空间）或者使用 repeat() 函数来创建重复的轨道。</p>
</li>
<li><p><strong>grid-template-areas</strong>：用于定义网格区域的名称，可以将元素放置到特定的区域中。</p>
</li>
<li><p><strong>grid-gap</strong> 或 <strong>grid-column-gap</strong> 和 <strong>grid-row-gap</strong>：用于设置网格内元素之间的间隙。</p>
</li>
<li><p><strong>justify-items</strong> 和 <strong>align-items</strong>：控制网格项（grid items）在水平和垂直方向上的对齐方式。</p>
</li>
<li><p><strong>place-items</strong>（简写）：同时设置 justify-items 和 align-items。</p>
</li>
<li><p><strong>grid-auto-columns</strong>、<strong>grid-auto-rows</strong> 和 <strong>grid-auto-flow</strong>：用于处理超出显式定义行列范围的网格项，自动填充和排列多余的网格项。</p>
</li>
<li><p><strong>grid-area</strong>：用于定义网格项占据的网格区域。</p>
</li>
<li><p><strong>justify-self</strong>、<strong>align-self</strong> 和 <strong>place-self</strong>：控制单个网格项在其所在单元格内的对齐方式，可以覆盖容器层面的对齐设置。</p>
</li>
</ul>
<h3 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Multiple-column_Layout#%E5%88%97%E4%B8%8E%E5%86%85%E5%AE%B9%E6%8A%98%E6%96%AD">多列布局</a></h3><p>多列布局（Multi-column Layout）是 CSS 中用于创建报纸或杂志样式的多列文章布局的功能。在 CSS 中，主要有以下几种方法实现多列布局：</p>
<ol>
<li><p><strong>CSS Multi-column Layout Module</strong>：</p>
<ul>
<li>使用 CSS 的多列布局模块，可以将一个块级元素的内容分成几列显示。</li>
<li>主要相关属性有：<ul>
<li><code>column-count</code>: 设置元素应该被分割的列数。</li>
<li><code>column-width</code>: 设置每列的理想宽度，浏览器会尽可能根据这个值来确定合适的列数。</li>
<li><code>column-gap</code>: 设置列之间的间距。</li>
<li><code>column-rule</code>: 设置列之间的边框样式、宽度和颜色。</li>
<li><code>break-inside</code>: 防止内容在列之间断开。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="css">.multi-column &#123;
  column-count: 3;
  column-gap: 20px;
  column-rule: 1px solid #ccc;
&#125;
</code></pre>
</li>
<li><p><strong>Flexbox</strong>：</p>
<ul>
<li>虽然 Flexbox 主要用于一维布局，但通过调整容器的方向（<code>flex-direction: column</code>），然后利用嵌套的 Flexbox 容器，也可以实现多列布局的效果。</li>
</ul>
</li>
<li><p><strong>CSS Grid Layout</strong>：</p>
<ul>
<li>CSS Grid 布局提供了一种更为强大和灵活的二维布局系统，非常适合创建多列布局。</li>
<li>使用 <code>grid-template-columns</code> 属性定义列的数量和大小，可以轻松创建多列布局。</li>
</ul>
<p>示例：</p>
<pre><code class="css">.grid-container &#123;
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* 创建三列 */
  gap: 20px; /* 列之间的间距 */
&#125;
</code></pre>
</li>
</ol>
<p>根据实际需求和浏览器兼容性，可以选择适合的方式来实现多列布局。在现代浏览器中，CSS Multi-column Layout Module 和 CSS Grid Layout 是实现多列布局最常用且功能丰富的技术。</p>
<h2 id="瀑布流布局"><a href="#瀑布流布局" class="headerlink" title="瀑布流布局"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024512687">瀑布流布局</a></h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CGkMY5WfbQtSCPTwwTdmPQ">深入解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.imooc.com/learn/101">视频</a></p>
<h2 id="图片变形"><a href="#图片变形" class="headerlink" title="图片变形"></a>图片变形</h2><h3 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/refe/p/5036117.html">clip-path</a></h3><p><code>clip-path</code> 是 CSS 中的一个属性，用于裁剪元素的可视区域，也就是定义一个只有在这个区域内内容才会被显示的剪切路径。它可以接受多种图形形状的值，包括圆形、椭圆、多边形、路径等，来裁剪元素的显示区域。</p>
<p>以下是一些常见的 <code>clip-path</code> 值：</p>
<ol>
<li><p><strong>基本形状</strong>：</p>
<ul>
<li><code>inset()</code>：创建一个矩形剪切区域，可以指定矩形的顶点坐标。</li>
</ul>
<pre><code class="css">clip-path: inset(10px 20px 30px 40px);
</code></pre>
<p>这里，<code>(10px 20px 30px 40px)</code> 分别代表上、右、下、左的内边距。</p>
</li>
<li><p><strong>几何形状</strong>：</p>
<ul>
<li><code>circle()</code>：创建一个圆形剪切区域，需要指定半径和中心点。</li>
</ul>
<pre><code class="css">clip-path: circle(50% at 50% 50%);
</code></pre>
<p>这里，<code>circle(50% at 50% 50%)</code> 表示一个以元素中心为圆心、半径为元素宽高的 50%的圆形。</p>
<ul>
<li><code>ellipse()</code>：创建一个椭圆剪切区域，也需要指定半径和中心点。</li>
</ul>
<pre><code class="css">clip-path: ellipse(75% 50% at 50% 50%);
</code></pre>
<p>这里，<code>ellipse(75% 50% at 50% 50%)</code> 表示一个以元素中心为焦点，水平半径为元素宽度的 75%，垂直半径为元素高度的 50%的椭圆。</p>
</li>
<li><p>**polygon()**：</p>
<ul>
<li>通过一系列坐标定义一个多边形剪切区域。</li>
</ul>
<pre><code class="css">clip-path: polygon(0 0, 100% 0%, 100% 100%, 0% 100%);
</code></pre>
<p>这里，<code>polygon(0 0, 100% 0%, 100% 100%, 0% 100%)</code> 定义了一个正方形剪切区域。</p>
</li>
<li><p><strong>URL 引用</strong>：</p>
<ul>
<li>通过 URL 引用 SVG 中的<code>&lt;clipPath&gt;</code>元素定义的剪切路径。</li>
</ul>
<pre><code class="css">clip-path: url(#myClipPath);
</code></pre>
<p>在对应的 SVG 文件或嵌入在 HTML 中的 SVG 中定义名为<code>myClipPath</code>的剪切路径。</p>
</li>
</ol>
<p>注意：<code>clip-path</code>属性对旧版本浏览器的支持程度不一，建议结合 <code>-webkit-clip-path</code> 等前缀属性以及渐进增强策略来确保更好的兼容性。此外，还可以使用 <code>mask</code> 属性作为 <code>clip-path</code> 的备选方案，以获得更广泛的支持。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">filter</a></h3><p><code>filter</code> 是 CSS 中的一个属性，用于对元素（如图片、背景或 SVG 图形）应用图形效果，如模糊、灰度、饱和度调整、阴影等。它可以在不依赖于图像处理软件的情况下，直接在浏览器中对元素进行实时滤镜处理。</p>
<p>以下是一些常见的 <code>filter</code> 属性值：</p>
<ol>
<li><p><strong>模糊效果</strong>：</p>
<ul>
<li><code>blur()</code>：对元素进行模糊处理。</li>
</ul>
<pre><code class="css">filter: blur(10px);
</code></pre>
</li>
<li><p><strong>灰度和饱和度调整</strong>：</p>
<ul>
<li><code>grayscale()</code>：将元素转换为灰度图像。</li>
</ul>
<pre><code class="css">filter: grayscale(100%); /* 完全灰度 */
</code></pre>
<ul>
<li><code>sepia()</code>：将元素转换为深褐色色调。</li>
</ul>
<pre><code class="css">filter: sepia(100%);
</code></pre>
<ul>
<li><code>saturate()</code>：增加或减少图像饱和度。</li>
</ul>
<pre><code class="css">filter: saturate(200%); /* 增加饱和度 */
</code></pre>
</li>
<li><p><strong>亮度和对比度调整</strong>：</p>
<ul>
<li><code>brightness()</code>：调整图像亮度。</li>
</ul>
<pre><code class="css">filter: brightness(200%); /* 提高亮度 */
</code></pre>
<ul>
<li><code>contrast()</code>：调整图像对比度。</li>
</ul>
<pre><code class="css">filter: contrast(200%); /* 提高对比度 */
</code></pre>
</li>
<li><p><strong>阴影效果</strong>：</p>
<ul>
<li><code>drop-shadow()</code>：给元素添加阴影效果。</li>
</ul>
<pre><code class="css">filter: drop-shadow(10px 10px 5px rgba(0, 0, 0, 0.5));
</code></pre>
</li>
<li><p><strong>组合多个滤镜</strong>：</p>
<ul>
<li>可以通过空格分隔多个滤镜效果，依次应用到元素上。</li>
</ul>
<pre><code class="css">filter: grayscale(50%) blur(5px);
</code></pre>
</li>
</ol>
<p>需要注意的是，<code>filter</code> 属性对浏览器的兼容性较好，但在一些较老的浏览器中可能不支持。因此，可以结合使用 <code>-webkit-filter</code> 前缀属性来提高兼容性。同时，过于复杂的滤镜可能会影响性能，尤其是在移动设备上，使用时需权衡视觉效果与性能之间的平衡。</p>
<h3 id="blend-mode"><a href="#blend-mode" class="headerlink" title="blend-mode"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/blend-mode">blend-mode</a></h3><p><code>mix-blend-mode</code>（混合模式）是 CSS 中的一个属性，它定义了元素的内容应该如何与其底层背景或下面的元素内容进行混合。混合模式允许元素的像素颜色与底层元素的像素颜色进行数学运算，产生合成效果，类似于在图像编辑软件（如 Photoshop）中使用的图层混合模式。</p>
<p><code>mix-blend-mode</code> 支持多种混合模式，包括但不限于以下几种：</p>
<ol>
<li><code>normal</code>：默认模式，元素不与其他元素混合，每个元素独立显示。</li>
<li><code>multiply</code>：将顶层元素的颜色值与底层元素的颜色值相乘，加深整体颜色。</li>
<li><code>screen</code>：将顶层元素的颜色与底层元素的颜色进行互补色相乘，再求反，产生亮化的混合效果。</li>
<li><code>overlay</code>：根据底层颜色的明暗程度，分别采用<code>multiply</code>或<code>screen</code>模式进行混合。</li>
<li><code>darken</code>：比较顶层和底层每个像素的亮度，选择较暗的那个颜色作为混合结果。</li>
<li><code>lighten</code>：比较顶层和底层每个像素的亮度，选择较亮的那个颜色作为混合结果。</li>
<li><code>color-dodge</code>：使底层颜色变得更亮，以反映顶层颜色的亮度信息。</li>
<li><code>color-burn</code>：使底层颜色变得更暗，以反映顶层颜色的黑暗信息。</li>
<li><code>hard-light</code>：根据顶层颜色的明暗程度，分别采用<code>color-dodge</code>或<code>color-burn</code>模式进行混合。</li>
<li><code>difference</code>：取两层颜色之差，产生强烈的对比效果。</li>
<li><code>hue</code>、<code>saturation</code>、<code>color</code>和<code>luminosity</code>：分别混合颜色的色相、饱和度、色度（色彩信息）和亮度信息。</li>
</ol>
<p>示例代码：</p>
<pre><code class="css">.element &#123;
  mix-blend-mode: multiply;
&#125;
</code></pre>
<p>这段 CSS 会让<code>.element</code>元素的内容与其下方的元素内容按照<code>multiply</code>模式进行混合。</p>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_transform.asp">transform</a></h3><p><code>transform</code> 是 CSS 中用于实现元素变形和位移的一种属性，它可以对元素进行旋转、缩放、倾斜、平移等操作，从而改变元素在视觉上的表现形式，而不影响其在文档流中的原始位置。<code>transform</code>属性适用于 2D 和 3D 转换，增强了网页布局的动态效果和交互体验。</p>
<p>以下是一些常见的 <code>transform</code> 属性值：</p>
<ol>
<li><p><strong>2D 变形</strong>：</p>
<ul>
<li><code>rotate()</code>：旋转元素。<pre><code class="css">transform: rotate(45deg);
</code></pre>
</li>
<li><code>scale()</code>：缩放元素。<pre><code class="css">transform: scale(1.5); /* 以元素中心点放大1.5倍 */
</code></pre>
</li>
<li><code>translate()</code>：平移元素。<pre><code class="css">transform: translate(
  50px,
  100px
); /* 水平向右移动50像素，垂直向下移动100像素 */
</code></pre>
</li>
<li><code>skew()</code>：倾斜元素。<pre><code class="css">transform: skewX(30deg); /* 沿X轴倾斜30度 */
</code></pre>
</li>
</ul>
</li>
<li><p><strong>3D 变形</strong>：</p>
<ul>
<li><code>rotate3d()</code>：三维旋转元素。<pre><code class="css">transform: rotate3d(1, 1, 0, 45deg);
</code></pre>
</li>
<li><code>scale3d()</code>：三维缩放元素。<pre><code class="css">transform: scale3d(1.5, 1, 1);
</code></pre>
</li>
<li><code>translate3d()</code>：三维平移元素。<pre><code class="css">transform: translate3d(50px, 100px, 0); /* 在Z轴为0的位置上平移 */
</code></pre>
</li>
</ul>
</li>
<li><p><strong>组合变形</strong>：</p>
<ul>
<li>可以通过空格分隔多个变形函数，按顺序依次应用。<pre><code class="css">transform: rotate(45deg) scale(1.5);
</code></pre>
</li>
</ul>
</li>
</ol>
<p>此外，<code>transform-origin</code> 属性可以用来设置变形的基点，即变形动作发生的参照点。<code>transform-style</code> 用于定义 3D 元素的子元素是否也为 3D 空间，<code>perspective</code> 用于设置透视效果，这些属性配合 <code>transform</code> 一起使用，可以创造出更丰富的视觉效果。</p>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/css/css3_animations.asp">animation</a></h3><p><code>animation</code> 是 CSS 中的一个复合属性，用于定义动画效果。它允许开发者创建并控制动画序列，包括动画名称、持续时间、延迟时间、迭代次数、速度曲线、播放方向等。</p>
<p>动画的工作原理是将一系列关键帧（keyframes）定义为 CSS 规则，然后将这些关键帧应用到元素上。关键帧定义了动画在各个时间段内的样式变化。</p>
<p><code>animation</code> 属性的组成部分包括：</p>
<ol>
<li><code>animation-name</code>：定义动画的名称，引用先前定义的关键帧名称。</li>
<li><code>animation-duration</code>：定义动画完成一个周期所花费的时间，通常以秒或毫秒为单位。</li>
<li><code>animation-timing-function</code>：定义动画的速度曲线，如匀速、加速、减速等。</li>
<li><code>animation-delay</code>：定义动画开始前等待的时间。</li>
<li><code>animation-iteration-count</code>：定义动画播放的次数，可以是整数值（表示播放次数）、<code>infinite</code>（无限次循环播放）或其他。</li>
<li><code>animation-direction</code>：定义动画播放的方向，如正常顺序播放、逆序播放、每次交替方向播放等。</li>
<li><code>animation-fill-mode</code>：定义动画结束后元素的样式，如保持最后一个关键帧的样式、回到初始关键帧的样式等。</li>
<li><code>animation-play-state</code>：控制动画是否正在运行，可以设置为 <code>running</code> 或 <code>paused</code>。</li>
</ol>
<p>示例代码：</p>
<pre><code class="css">@keyframes fadeInOut &#123;
  0% &#123;
    opacity: 0;
  &#125;
  50% &#123;
    opacity: 1;
  &#125;
  100% &#123;
    opacity: 0;
  &#125;
&#125;

.box &#123;
  animation: fadeInOut 2s ease-in-out infinite;
&#125;
</code></pre>
<p>在这个示例中，我们首先定义了一个名为 <code>fadeInOut</code> 的动画，该动画描述了元素从透明度 0 逐渐变为 1 然后再变回 0 的过程。接着在 <code>.box</code> 类的样式中应用了这个动画，设置了动画的名称、持续时间为 2 秒、速度曲线为 ease-in-out，并设置无限次循环播放。</p>
<h2 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011349149/article/details/24181675">雪碧图</a></h2><p><a target="_blank" rel="noopener" href="https://www.imooc.com/learn/93">视频</a></p>
<p>CSS Sprite 是一种网页优化技术，主要用于减少 HTTP 请求的数量，从而提高网页加载速度。通过将多个小图标或者背景图像合并到一张大图中，然后利用 CSS 的背景定位 background-position 属性来显示需要的部分。</p>
<p>具体实现方式是：</p>
<ol>
<li>创建一个包含所有小图标的单一图像文件，即“Sprite”图片。</li>
<li>在 CSS 中为每个需要用到这些小图标的元素定义背景图片（指向整个 Sprite 图片）。</li>
<li>使用<code>background-position</code>属性精确地指定每个元素应该显示 Sprite 图片中的哪个部分。例如，如果第一个图标位于 Sprite 图片的左上角（0, 0），而第二个图标在其下方，则可以分别为两个元素设置不同的偏移量。</li>
</ol>
<p>例如：</p>
<pre><code class="css">.icon1 &#123;
  width: 20px;
  height: 20px;
  background-image: url(&quot;spritesheet.png&quot;);
  background-position: 0 0; /* 显示Sprite图片左上角的内容 */
&#125;

.icon2 &#123;
  width: 20px;
  height: 20px;
  background-image: url(&quot;spritesheet.png&quot;);
  background-position: -20px 0; /* 假设第二个图标距离第一个图标20px，向下移动显示下一个图标 */
&#125;
</code></pre>
<p>通过这种方法，浏览器只需加载一个较大的图像文件，而不是分别加载每个小图标，减少了 HTTP 请求和网络传输的时间开销，有助于提升网站性能。同时，要注意合理布局 Sprite 图片中的元素，以便于计算每个元素对应的背景位置坐标。</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在 JavaScript 中，<code>undefined</code>、<code>null</code> 和 <code>NaN</code> 是三种不同的值，各自代表不同的意义和用途：</p>
<ol>
<li><p><strong>undefined</strong>：</p>
<ul>
<li>类型：<code>undefined</code> 是一种基本数据类型。</li>
<li>含义：表示变量已声明但未初始化，或者对象属性不存在时返回的值。在 JavaScript 中，函数没有明确返回值时，也会返回 <code>undefined</code>。</li>
<li>特性：<code>typeof undefined</code> 返回 <code>&#39;undefined&#39;</code>，<code>undefined == null</code> 为 <code>true</code>，这是因为 JavaScript 在执行相等性检查时会进行类型转换，把 <code>undefined</code> 视为 <code>null</code>。</li>
</ul>
</li>
<li><p><strong>null</strong>：</p>
<ul>
<li>类型：在 JavaScript 中，<code>null</code> 通常被认为是一个特殊的对象值，但实际上它是一个类型，typeof <code>null</code> 返回 <code>&#39;object&#39;</code>，但这被视为 JavaScript 的一个历史遗留错误。</li>
<li>含义：表示一个空值或者无对象值，它有意表示没有任何对象值或者没有对象被引用。<code>null</code> 是一个明确的标识，表明一个变量是有意为之的空值。</li>
<li>特性：尽管 <code>null</code> 类型特殊，但是在相等性检查时，<code>null == undefined</code> 为 <code>true</code>，但 <code>null === undefined</code> 为 <code>false</code>，因为它们虽然在宽松相等检查中被认为是相等的，但在严格相等检查时类型不同。</li>
</ul>
</li>
<li><p><strong>NaN</strong>：</p>
<ul>
<li>类型：<code>NaN</code> 是 <code>Not-A-Number</code> 的缩写，也是 JavaScript 中的一种特殊类型，属于 <code>Number</code> 类型，但不是一个正常的数字值。</li>
<li>含义：当一个数学运算的结果无法表示为数字时，JavaScript 会返回 <code>NaN</code>。例如，<code>0/0</code>、<code>Math.sqrt(-1)</code> 或者将一个非数字的字符串转换为数字（如 <code>Number(&quot;abc&quot;)</code>）都会得到 <code>NaN</code>。</li>
<li>特性：<code>NaN</code> 不等于任何值，包括它自身，即 <code>NaN === NaN</code> 为 <code>false</code>。可以使用全局方法 <code>isNaN()</code> 或者 <code>Number.isNaN()</code> 来检测一个值是否为 <code>NaN</code>。</li>
</ul>
</li>
</ol>
<p>总结来说，<code>undefined</code> 表示变量尚未初始化或属性不存在，<code>null</code> 表示故意设置的空值，而 <code>NaN</code> 表示无法表示为数字的特殊值。在实际编程中，理解和正确处理这些值对避免程序错误至关重要。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/function-basics">函数</a></h2><p>JavaScript 函数是可重用的代码块，用于执行特定任务并在需要时返回结果。在 JavaScript 中，函数定义和使用的基本形式如下：</p>
<p><strong>定义函数</strong>：</p>
<pre><code class="javascript">// 使用函数声明（function declaration）
function functionName(parameters) &#123;
  // 函数体（包含执行的代码）
  statements;
  return value; // 可选，用于返回函数结果
&#125;

// 使用函数表达式（function expression）
const functionName = function (parameters) &#123;
  // 函数体
  statements;
  return value;
&#125;;

// 使用箭头函数（Arrow Function Expression）
const functionName = (parameters) =&gt; &#123;
  // 函数体，如果只有一个表达式并且不需要花括号，则可以省略花括号和return关键字
  return value;
&#125;;
</code></pre>
<p><strong>调用函数</strong>：</p>
<pre><code class="javascript">functionName(argumentValues);
</code></pre>
<p><strong>参数和返回值</strong>：</p>
<ul>
<li>函数定义时在函数名后面的括号内可以定义零个或多个参数，这些参数在函数调用时接收传递的值。</li>
<li>函数体内的 <code>return</code> 语句用于结束函数执行并返回一个值。如果不返回任何值，函数默认返回 <code>undefined</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="javascript">// 函数声明
function add(a, b) &#123;
  return a + b;
&#125;

// 调用函数并打印结果
console.log(add(3, 5)); // 输出：8

// 函数表达式
const subtract = function (x, y) &#123;
  return x - y;
&#125;;

console.log(subtract(8, 3)); // 输出：5

// 箭头函数
const multiply = (num1, num2) =&gt; num1 * num2;

console.log(multiply(2, 4)); // 输出：8
</code></pre>
<p>除了基本的函数，JavaScript 还支持闭包、函数作为参数传递、函数作为返回值等功能，使得 JavaScript 函数功能极其强大和灵活。</p>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Strings">文本处理</a></h2><p>JavaScript 提供了一系列内置的文本处理方法，用于处理字符串和文本内容。以下是一些常见的文本处理方法和功能：</p>
<ol>
<li><p><strong>字符串拼接</strong>：</p>
<ul>
<li>使用加号 <code>+</code> 进行字符串连接。</li>
</ul>
<pre><code class="javascript">var str1 = &quot;Hello&quot;;
var str2 = &quot;world&quot;;
var result = str1 + &quot; &quot; + str2; // 结果为 &quot;Hello world&quot;
</code></pre>
<ul>
<li>使用模板字符串（Template Literals）：</li>
</ul>
<pre><code class="javascript">const name = &quot;John&quot;;
const message = `Hello, $&#123;name&#125;!`; // 结果为 &quot;Hello, John!&quot;
</code></pre>
</li>
<li><p><strong>字符串长度</strong>：</p>
<ul>
<li><code>length</code> 属性获取字符串长度。</li>
</ul>
<pre><code class="javascript">var str = &quot;Hello World&quot;;
console.log(str.length); // 输出 11
</code></pre>
</li>
<li><p><strong>提取子串</strong>：</p>
<ul>
<li><code>substring()</code> 方法提取字符串的一部分。</li>
</ul>
<pre><code class="javascript">var subStr = str.substring(6, 11); // 结果为 &quot;World&quot;
</code></pre>
<ul>
<li><code>slice()</code> 方法也有类似的用途。</li>
</ul>
<pre><code class="javascript">var subStr = str.slice(6, 11); // 结果同样为 &quot;World&quot;
</code></pre>
<ul>
<li><code>substr()</code> 方法也提取子字符串，但参数略有不同。</li>
</ul>
<pre><code class="javascript">var subStr = str.substr(6, 5); // 结果为 &quot;World&quot;
</code></pre>
</li>
<li><p><strong>查找子串</strong>：</p>
<ul>
<li><code>indexOf()</code> 方法查找子字符串出现的第一个索引。</li>
</ul>
<pre><code class="javascript">var index = str.indexOf(&quot;World&quot;); // 输出 6
</code></pre>
<ul>
<li><code>includes()</code> 方法检查字符串是否包含另一个子字符串。</li>
</ul>
<pre><code class="javascript">var hasWorld = str.includes(&quot;World&quot;); // 输出 true
</code></pre>
</li>
<li><p><strong>替换子串</strong>：</p>
<ul>
<li><code>replace()</code> 方法用于替换字符串中的某个子串。</li>
</ul>
<pre><code class="javascript">var newStr = str.replace(&quot;World&quot;, &quot;Universe&quot;); // 结果为 &quot;Hello Universe&quot;
</code></pre>
</li>
<li><p><strong>转换大小写</strong>：</p>
<ul>
<li><code>toUpperCase()</code> 方法将字符串转换为大写。</li>
</ul>
<pre><code class="javascript">var upperCaseStr = str.toUpperCase(); // 结果为 &quot;HELLO WORLD&quot;
</code></pre>
<ul>
<li><code>toLowerCase()</code> 方法将字符串转换为小写。</li>
</ul>
<pre><code class="javascript">var lowerCaseStr = str.toLowerCase(); // 结果为 &quot;hello world&quot;
</code></pre>
</li>
<li><p><strong>trim()</strong> 方法去除字符串两端的空白字符。</p>
<pre><code class="javascript">var trimmedStr = &quot;   Hello World   &quot;.trim(); // 结果为 &quot;Hello World&quot;
</code></pre>
</li>
<li><p><strong>split()</strong> 方法将字符串分割为数组。</p>
<pre><code class="javascript">var words = str.split(&quot; &quot;); // 结果为 [&quot;Hello&quot;, &quot;World&quot;]
</code></pre>
</li>
<li><p><strong>字符串模板</strong>：</p>
<ul>
<li>使用反引号 &#96; backticks 创建多行或嵌入表达式的字符串。</li>
</ul>
<pre><code class="javascript">let name = &quot;Alice&quot;;
let greeting = `Hello, $&#123;name&#125;!`; // 结果为 &quot;Hello, Alice!&quot;
</code></pre>
</li>
<li><p>正则表达式：</p>
<ul>
<li>JavaScript 中可以结合正则表达式进行更复杂的文本处理，如匹配、查找、替换等操作。</li>
</ul>
</li>
</ol>
<h3 id="有用的字符串方法"><a href="#有用的字符串方法" class="headerlink" title="有用的字符串方法"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Useful_string_methods">有用的字符串方法</a></h3><p>JavaScript 中有许多有用的字符串方法，以下是其中一些常见的和实用的：</p>
<ol>
<li><p><strong>获取长度</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
console.log(str.length); // 输出13
</code></pre>
</li>
<li><p><strong>拼接字符串</strong>：</p>
<pre><code class="javascript">var str1 = &quot;Hello, &quot;;
var str2 = &quot;World!&quot;;
var combined = str1 + str2; // 输出 &quot;Hello, World!&quot;
</code></pre>
<p>或者使用模板字符串（ES6+）：</p>
<pre><code class="javascript">var name = &quot;World&quot;;
var greeting = `Hello, $&#123;name&#125;!`; // 输出 &quot;Hello, World!&quot;
</code></pre>
</li>
<li><p><strong>检索子串</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
console.log(str.indexOf(&quot;World&quot;)); // 输出 7，找到&quot;World&quot;的第一个字符索引
</code></pre>
</li>
<li><p><strong>替换子串</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
var replaced = str.replace(&quot;World&quot;, &quot;Earth&quot;);
console.log(replaced); // 输出 &quot;Hello, Earth!&quot;
</code></pre>
</li>
<li><p><strong>提取子串</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
console.log(str.substring(7)); // 输出 &quot;World!&quot;
console.log(str.slice(7)); // 输出 &quot;World!&quot;

// 使用 start 和 end 索引
console.log(str.substring(7, 12)); // 输出 &quot;World&quot;
console.log(str.slice(7, 12)); // 输出 &quot;World&quot;
</code></pre>
</li>
<li><p><strong>转换大小写</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
console.log(str.toUpperCase()); // 输出 &quot;HELLO, WORLD!&quot;
console.log(str.toLowerCase()); // 输出 &quot;hello, world!&quot;
</code></pre>
</li>
<li><p><strong>查找字符</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
console.log(str.charAt(0)); // 输出 &quot;H&quot;
</code></pre>
</li>
<li><p><strong>截取字符串</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
console.log(str.slice(-5)); // 输出 &quot;World!&quot;，从末尾截取5个字符
console.log(str.substr(-5)); // 输出 &quot;World!&quot;，从倒数第五个字符开始截取到字符串末尾
console.log(str.substring(0, 5)); // 输出 &quot;Hello&quot;，从0开始截取到第5个字符（不包括第5个）
</code></pre>
</li>
<li><p><strong>拆分字符串</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
var arr = str.split(&quot;, &quot;); // 输出 [&quot;Hello&quot;, &quot;World!&quot;]
</code></pre>
</li>
<li><p><strong>修剪空格</strong>：</p>
<pre><code class="javascript">var str = &quot;   Hello, World!   &quot;;
console.log(str.trim()); // 输出 &quot;Hello, World!&quot;
</code></pre>
</li>
<li><p><strong>检查是否以某个字符串开始或结束</strong>：</p>
<pre><code class="javascript">var str = &quot;Hello, World!&quot;;
console.log(str.startsWith(&quot;Hello&quot;)); // 输出 true
console.log(str.endsWith(&quot;!&quot;)); // 输出 true
</code></pre>
</li>
<li><p><strong>正则表达式相关方法</strong>：</p>
<pre><code class="javascript">var str = &quot;I love JavaScript.&quot;;
console.log(str.match(/love/i)[0]); // 输出 &quot;love&quot;，忽略大小写匹配 &quot;love&quot;
console.log(str.replace(/JavaScript/, &quot;programming&quot;)); // 输出 &quot;I love programming.&quot;
</code></pre>
</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">数组</a></h2><p>JavaScript 数组是有序的数据集合，可以存储任意类型的多个值。数组在 JavaScript 中是一个对象，但它具有自己的特殊性质和方法。下面是一些关于 JavaScript 数组的基础概念和操作：</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><h4 id="方式一：构造函数创建"><a href="#方式一：构造函数创建" class="headerlink" title="方式一：构造函数创建"></a>方式一：构造函数创建</h4><pre><code class="javascript">let arr1 = new Array(); // 创建一个空数组
let arr2 = new Array(3); // 创建一个长度为3的空数组，元素默认为undefined
let arr3 = new Array(1, 2, 3, 4); // 创建一个包含四个元素的数组
</code></pre>
<h4 id="方式二：字面量创建"><a href="#方式二：字面量创建" class="headerlink" title="方式二：字面量创建"></a>方式二：字面量创建</h4><pre><code class="javascript">let arr = []; // 创建一个空数组
let arr = [1, 2, 3, 4]; // 创建一个包含四个元素的数组
</code></pre>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><pre><code class="javascript">let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;];
console.log(fruits[0]); // 输出 &#39;apple&#39;，数组的索引是从0开始的
</code></pre>
<h3 id="修改和添加元素"><a href="#修改和添加元素" class="headerlink" title="修改和添加元素"></a>修改和添加元素</h3><pre><code class="javascript">fruits[0] = &quot;orange&quot;; // 修改第一个元素
fruits.push(&quot;date&quot;); // 在数组末尾添加元素
</code></pre>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><pre><code class="javascript">fruits.pop(); // 删除并返回数组最后一个元素
fruits.shift(); // 删除并返回数组第一个元素
arr.splice(index, 1); // 删除指定索引位置的元素
</code></pre>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><pre><code class="javascript">let index = fruits.indexOf(&quot;banana&quot;); // 返回 &#39;banana&#39; 在数组中的索引，若不存在则返回 -1
</code></pre>
<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/chinese/news/javascript-array-foreach-tutorial-how-to-iterate-through-elements-in-an-array-with-map/">遍历数组</a></h3><pre><code class="javascript">for (let i = 0; i &lt; fruits.length; i++) &#123;
  console.log(fruits[i]);
&#125;

// 或者使用 forEach 方法遍历
fruits.forEach(function (item, index, array) &#123;
  console.log(item);
&#125;);
</code></pre>
<h3 id="数组的其他方法"><a href="#数组的其他方法" class="headerlink" title="数组的其他方法"></a>数组的其他方法</h3><ul>
<li><code>length</code> 属性：获取数组的长度（元素数量）。</li>
<li><code>join(separator)</code> 方法：将数组元素连接成一个字符串，可指定分隔符，默认是逗号。</li>
<li><code>slice(start, end)</code> 方法：提取数组的一部分，返回一个新的数组。</li>
<li><code>sort(compareFunction)</code> 方法：对数组元素进行排序，默认按照字符串排序，可以提供比较函数定制排序规则。</li>
<li><code>reverse()</code> 方法：颠倒数组中元素的顺序。</li>
<li><code>concat(array2, ...[, arrayN])</code> 方法：将一个或多个数组（或值）与原数组合并，返回新数组，原数组不变。</li>
</ul>
<h3 id="ES6-新增方法"><a href="#ES6-新增方法" class="headerlink" title="ES6 新增方法"></a>ES6 新增方法</h3><ul>
<li><code>Array.from()</code>：将类数组对象或可迭代对象转换为数组。</li>
<li><code>Array.of()</code>：创建一个具有可变数量参数的新数组实例。</li>
<li><code>find(callbackFn[, thisArg])</code>：查找数组中满足提供的测试函数的第一个元素。</li>
<li><code>findIndex(callbackFn[, thisArg])</code>：查找数组中满足提供的测试函数的第一个元素的索引。</li>
<li><code>map()</code>、<code>filter()</code>、<code>reduce()</code>、<code>forEach()</code> 等方法用于高级数组操作和处理。</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">对象</a></h2><p>JavaScript 中的对象是一种数据结构，用于存储键值对集合，其中每个键是一个字符串（在 ES6 中也可以是 Symbol），每个值可以是任意类型的数据，包括但不限于字符串、数字、布尔值、函数、数组，甚至是其他对象。JavaScript 对象是动态类型的，允许在运行时添加、删除和修改其属性。</p>
<p>创建对象的常见方式有：</p>
<ol>
<li><strong>对象字面量</strong>（Literal Notation）：</li>
</ol>
<pre><code class="javascript">let obj = &#123;
  property1: &quot;value1&quot;,
  property2: 123,
  method: function () &#123;
    console.log(&quot;Method called&quot;);
  &#125;,
&#125;;
</code></pre>
<ol start="2">
<li><strong>构造函数</strong>（Constructor Function）：</li>
</ol>
<pre><code class="javascript">function Person(name, age) &#123;
  this.name = name;
  this.age = age;
&#125;

let person = new Person(&quot;Alice&quot;, 25);
</code></pre>
<ol start="3">
<li><strong>对象创建方法</strong>：</li>
</ol>
<ul>
<li><code>Object.create()</code>：使用原型创建新对象。</li>
<li><code>Object.assign()</code>：合并源对象的属性到目标对象。</li>
</ul>
<p>JavaScript 对象属性可以动态访问和修改：</p>
<pre><code class="javascript">obj.property1 = &quot;new value&quot;;
console.log(obj.property1); // 输出 &#39;new value&#39;

// 动态添加属性
obj.newProperty = &quot;added dynamically&quot;;
console.log(obj.newProperty); // 输出 &#39;added dynamically&#39;

// 删除属性
delete obj.property1;
</code></pre>
<p>对象还可以通过<code>for...in</code>循环或<code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code>方法进行遍历。</p>
<p>ECMAScript 6（ES6）引入了<code>class</code>关键字，它为定义类提供了更清晰的语法，但实际上类还是基于原型的 JavaScript 对象。</p>
<pre><code class="javascript">class Car &#123;
  constructor(make, model) &#123;
    this.make = make;
    this.model = model;
  &#125;

  drive() &#123;
    console.log(`$&#123;this.make&#125; $&#123;this.model&#125; is driving.`);
  &#125;
&#125;

let myCar = new Car(&quot;Toyota&quot;, &quot;Camry&quot;);
myCar.drive(); // 输出 &#39;Toyota Camry is driving.&#39;
</code></pre>
<p>此外，JavaScript 对象还有一个重要的概念叫“原型链”，它决定了对象如何查找属性和方法，以及继承关系。</p>
<h2 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a></h3><p>解构赋值是 JavaScript 中的一项特性，允许将数组或对象的属性或数组元素的值直接提取并赋值给一组变量。这种语法简化了从复杂数据结构中提取多个值的操作，使得代码更简洁易读。</p>
<p><strong>数组的解构赋值：</strong></p>
<pre><code class="javascript">let arr = [1, 2, 3, 4];
let [a, b, c] = arr;
console.log(a); // 输出：1
console.log(b); // 输出：2
console.log(c); // 输出：3
// 注意，数组剩余部分可以用...运算符收集
let [first, second, ...rest] = arr;
console.log(rest); // 输出：[3, 4]
</code></pre>
<p><strong>对象的解构赋值：</strong></p>
<pre><code class="javascript">let obj = &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, age: 30 &#125;;
let &#123; firstName, lastName &#125; = obj;
console.log(firstName); // 输出：&#39;John&#39;
console.log(lastName); // 输出：&#39;Doe&#39;

// 如果属性名和变量名不同，可以指定
let &#123; firstName: givenName, lastName: familyName &#125; = obj;
console.log(givenName); // 输出：&#39;John&#39;
console.log(familyName); // 输出：&#39;Doe&#39;
</code></pre>
<p><strong>默认值：</strong></p>
<p>解构赋值可以设置默认值，当尝试解构的属性不存在或者值为 <code>undefined</code> 时，会使用默认值。</p>
<pre><code class="javascript">let &#123; firstName = &quot;Default&quot;, age = 20 &#125; = &#123; firstName: &quot;John&quot; &#125;;
console.log(firstName); // 输出：&#39;John&#39;
console.log(age); // 输出：20，因为age在对象中未定义，所以使用了默认值20
</code></pre>
<p><strong>嵌套解构：</strong></p>
<p>解构赋值还可以用于嵌套的对象和数组。</p>
<pre><code class="javascript">let nestedObj = &#123; user: &#123; name: &quot;Alice&quot;, age: 25 &#125;, pets: [&quot;cat&quot;, &quot;dog&quot;] &#125;;
let &#123;
  user: &#123; name &#125;,
  pets: [pet1, pet2 = &quot;fish&quot;],
&#125; = nestedObj;
console.log(name); // 输出：&#39;Alice&#39;
console.log(pet1); // 输出：&#39;cat&#39;
console.log(pet2); // 输出：&#39;dog&#39;，即使pets数组中没有第二个元素，pet2也会有默认值&#39;fish&#39;
</code></pre>
<h3 id="箭头函数表达式"><a href="#箭头函数表达式" class="headerlink" title="箭头函数表达式"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数表达式</a></h3><p>箭头函数表达式（Arrow Function Expression）是 ECMAScript 6（ES6）引入的一种简洁的函数定义语法。箭头函数以其简洁的语法和特殊的<code>this</code>绑定机制，在 JavaScript 中广泛应用。</p>
<p>基本语法结构如下：</p>
<pre><code class="javascript">(param1, param2, ..., paramN) =&gt; expression // 单行表达式体，没有大括号 &#123;&#125;
(param1, param2, ..., paramN) =&gt; &#123; statements &#125; // 多行语句体，需要用大括号包裹
</code></pre>
<ul>
<li>当箭头函数的函数体只有一行代码，并且不需要返回值时，可以省略大括号，此时函数的返回值是这一行表达式的计算结果。</li>
<li>当函数体有多行代码或需要明确返回一个值时，则需要使用大括号包裹代码块，并在需要返回值时使用<code>return</code>关键字。</li>
</ul>
<p>箭头函数的一些重要特性包括：</p>
<ol>
<li><p><strong>简洁语法</strong>：相较于传统的函数声明和函数表达式，箭头函数的语法更为简洁。</p>
</li>
<li><p><strong>隐式返回</strong>：当函数体只包含一个表达式时，可以省略<code>return</code>关键字，函数会自动返回该表达式的值。</p>
</li>
<li><p><strong><code>this</code>绑定</strong>：箭头函数没有自己的<code>this</code>上下文，它会捕获其所在（即定义的位置）上下文的<code>this</code>值，也就是说箭头函数的<code>this</code>值是静态的，不会受调用方式的影响。</p>
</li>
</ol>
<p>例如：</p>
<pre><code class="javascript">const add = (x, y) =&gt; x + y; // 单行表达式箭头函数，没有显式return，自动返回结果

const multiply = (x, y) =&gt; &#123;
  let product = x * y;
  return product; // 多行语句体箭头函数，需要明确return
&#125;;

let obj = &#123;
  count: 1,
  increment: () =&gt; this.count++, // 这里的this将绑定到obj对象，而不是调用increment函数时的上下文
&#125;;
</code></pre>
<p>总的来说，箭头函数不仅简化了代码编写，还在很大程度上解决了 JavaScript 中<code>this</code>指向的常见问题。</p>
<h3 id="可选链运算符"><a href="#可选链运算符" class="headerlink" title="可选链运算符(?.)"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining">可选链运算符(?.)</a></h3><p>可选链运算符（?.）是 JavaScript 语言中的一个特性，它允许在尝试访问对象的深层属性或调用方法时，如果在链式路径中的任何一个引用是 null 或 undefined，则整个表达式返回 undefined，而不会抛出 TypeError 异常。</p>
<p>例如：</p>
<pre><code class="javascript">const obj = &#123;
  nested: &#123;
    prop: &quot;value&quot;,
  &#125;,
&#125;;

// 不使用可选链运算符
console.log(obj.nested.prop); // 如果 obj 或 obj.nested 不存在，则会抛出 TypeError

// 使用可选链运算符
console.log(obj?.nested?.prop); // 如果 obj 或 obj.nested 不存在，输出 undefined，而不是抛出错误
</code></pre>
<p>在上面的例子中，<code>obj?.nested?.prop</code> 表达式首先检查 <code>obj</code> 是否存在，如果存在则继续查找 <code>obj.nested</code>，如果 <code>nested</code> 也存在，则返回 <code>prop</code> 的值；只要链式调用中的任意一项为 <code>null</code> 或 <code>undefined</code>，表达式就会立即停止计算并返回 <code>undefined</code>。</p>
<p>这种运算符极大地提高了代码的健壮性和可读性，尤其是在处理嵌套很深的对象属性或不确定对象结构时。</p>
<h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符(??)"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing">空值合并运算符(??)</a></h3><p>JavaScript 中的空值合并运算符（Nullish Coalescing Operator）<code>??</code> 是一个逻辑运算符，它用于在左侧表达式为 <code>null</code> 或 <code>undefined</code> 时，返回右侧表达式的值。如果左侧表达式的值既不是 <code>null</code> 也不是 <code>undefined</code>，那么就返回左侧表达式的值。</p>
<p>使用语法：</p>
<pre><code class="javascript">variable ?? default_value;
</code></pre>
<p>这里的 <code>variable</code> 是要检查的变量或表达式，如果它的值为 <code>null</code> 或 <code>undefined</code>，则表达式返回 <code>default_value</code> 的值。否则，返回 <code>variable</code> 的值。</p>
<p>举例说明：</p>
<pre><code class="javascript">let name = null;
let welcomeMessage = name ?? &quot;Guest&quot;; // welcomeMessage 将会是 &quot;Guest&quot;，因为 name 为 null

let age = 25;
let ageMessage = age ?? &quot;Age unknown&quot;; // ageMessage 将会是 25，因为 age 有一个非空值
</code></pre>
<p>空值合并运算符与逻辑或运算符 <code>||</code> 的区别在于，<code>||</code> 在左侧表达式值为 falsy（例如：<code>0</code>、<code>&#39;&#39;</code>（空字符串）、<code>false</code> 等）时也会返回右侧表达式的值，而 <code>??</code> 只在 <code>null</code> 或 <code>undefined</code> 时才返回右侧表达式。这就意味着，如果你只想在变量未定义或显式设置为 <code>null</code> 时提供默认值，<code>??</code> 是更为精确的选择。</p>
<h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document">Document</a></h2><p>在 Web 开发中，<code>document</code> 是浏览器提供的全局对象，它是 HTML DOM（Document Object Model）的根节点，代表了整个 HTML 文档。通过 <code>document</code> 对象，开发者可以访问和操作网页上的所有 HTML 元素、属性以及内容。</p>
<p>以下是 <code>document</code> 对象的一些主要功能和属性：</p>
<ol>
<li><p><strong>属性</strong>：</p>
<ul>
<li><code>document.URL</code>: 返回当前文档的 URL。</li>
<li><code>document.title</code>: 获取或设置当前文档的标题。</li>
<li><code>document.body</code>: 获取文档的 <code>&lt;body&gt;</code> 元素。</li>
</ul>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><code>document.getElementById(id)</code>: 通过 ID 获取页面上的某个元素。</li>
<li><code>document.querySelector(selector)</code>: 使用 CSS 选择器获取匹配的第一个元素。</li>
<li><code>document.querySelectorAll(selector)</code>: 获取匹配 CSS 选择器的所有元素列表。</li>
<li><code>document.createElement(tagName)</code>: 创建一个新的 HTML 元素。</li>
<li><code>document.appendChild(element)</code>: 向文档的某个元素内部追加子元素。</li>
<li><code>document.write(text)</code>: 向文档写入文本或 HTML 表达式，通常用于文档加载期间，但在文档加载完毕后再调用会重写整个文档。</li>
</ul>
</li>
<li><p><strong>事件监听</strong>：</p>
<ul>
<li><code>document.addEventListener(eventType, handlerFunction, options)</code>: 为文档添加事件监听器。</li>
</ul>
</li>
<li><p><strong>遍历文档结构</strong>：</p>
<ul>
<li><code>document.getElementsByTagName(tagName)</code>: 获取文档中所有指定标签名的元素。</li>
<li><code>document.getElementsByClassName(className)</code>: 获取文档中所有指定类名的元素。</li>
</ul>
</li>
</ol>
<p>通过 <code>document</code> 对象，我们可以动态地修改页面内容、添加或删除元素、响应用户交互事件以及获取或设置 HTML 元素的各种属性和内容。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="document-querySelector"><a href="#document-querySelector" class="headerlink" title="document.querySelector()"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector">document.querySelector()</a></h4><p><code>document.querySelector()</code> 是一个在 JavaScript 中用于获取 HTML 文档中匹配指定 CSS 选择器的第一个元素的方法。该方法属于 <code>document</code> 对象，返回的是符合条件的 DOM 元素的引用，如果没有匹配的元素，则返回 <code>null</code>。</p>
<p>基本语法如下：</p>
<pre><code class="javascript">const element = document.querySelector(selector);
</code></pre>
<ul>
<li><code>selector</code>：必填参数，接受一个字符串作为 CSS 选择器，用来指定要查找的元素。</li>
</ul>
<p>例如：</p>
<pre><code class="javascript">// 获取页面上第一个id为&quot;myId&quot;的元素
const myElement = document.querySelector(&quot;#myId&quot;);

// 获取页面上第一个类名为&quot;myClass&quot;的元素
const classElement = document.querySelector(&quot;.myClass&quot;);

// 获取页面上第一个类型为&quot;button&quot;的元素
const buttonElement = document.querySelector(&quot;button&quot;);
</code></pre>
<p>请注意，<code>querySelector()</code> 方法只会返回匹配到的第一个元素。如果你需要获取所有匹配的选择器，请使用 <code>document.querySelectorAll()</code> 方法，它会返回一个 NodeList（类似数组的对象），包含了所有匹配的选择器的元素。</p>
<h3 id="DOM-表单事件"><a href="#DOM-表单事件" class="headerlink" title="DOM 表单事件"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/introduction-browser-events">DOM 表单事件</a></h3><h4 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener()</a></h4><p><code>addEventListener()</code> 是 JavaScript 事件处理模型中一个重要的方法，主要用于给 DOM 元素或其他实现了 <code>EventTarget</code> 接口的对象绑定事件监听器。当指定的事件在目标元素上触发时，预先注册的监听器函数将会被执行。</p>
<p>语法：</p>
<pre><code class="javascript">target.addEventListener(type, listener[, options]);
</code></pre>
<p>参数说明：</p>
<ul>
<li><p><code>type</code>（必需）：字符串，代表要监听的事件类型，例如 <code>&#39;click&#39;</code>、<code>&#39;mouseover&#39;</code> 等。</p>
</li>
<li><p><code>listener</code>（必需）：事件处理器函数，当指定的 <code>type</code> 事件发生时，这个函数会被调用。也可以是一个实现了 <code>EventListener</code> 接口的对象。</p>
</li>
<li><p><code>options</code>（可选）：一个可选对象，用于指定附加选项。可以包含以下属性：</p>
<ul>
<li><code>capture</code>：布尔值，表示事件是否在捕获阶段触发监听器，默认为 <code>false</code>，即冒泡阶段触发。</li>
<li><code>once</code>：布尔值，表示监听器是否只执行一次，之后自动移除，默认为 <code>false</code>。</li>
<li><code>passive</code>：布尔值，指示浏览器是否应在被动式（passive）监听器上阻止默认行为。如果设置为 <code>true</code>，表示永远不会调用 <code>preventDefault()</code> 来阻止默认行为。</li>
</ul>
</li>
</ul>
<p>示例代码：</p>
<pre><code class="javascript">// 给一个id为&#39;myButton&#39;的HTML元素绑定点击事件
var myButton = document.getElementById(&quot;myButton&quot;);

myButton.addEventListener(&quot;click&quot;, function (event) &#123;
  console.log(&quot;Button clicked!&quot;);
&#125;);

// 使用箭头函数
myButton.addEventListener(
  &quot;click&quot;,
  (event) =&gt; &#123;
    console.log(&quot;Button clicked using arrow function!&quot;);
  &#125;,
  &#123; once: true &#125;
); // 只触发一次
</code></pre>
<p>在这个例子中，当用户点击 id 为<code>myButton</code>的按钮时，会打印出消息到控制台。同时，第二个监听器只会触发一次，然后自动移除。</p>
<h4 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/removeEventListener">EventTarget.removeEventListener()</a></h4><p><code>EventTarget.removeEventListener()</code> 是 JavaScript 中的一个方法，用于从指定的 EventTarget（即能接收事件的对象，如 DOM 元素、Window 等）上移除之前通过 <code>addEventListener()</code> 添加的事件监听器。</p>
<p>这个方法接受三个参数：</p>
<ol>
<li><p><code>type</code>（必需）：字符串，表示要移除的事件类型，例如 <code>&#39;click&#39;</code>、<code>&#39;load&#39;</code> 等。</p>
</li>
<li><p><code>listener</code>（必需）：事件处理函数，即之前通过 <code>addEventListener()</code> 注册的函数。</p>
</li>
<li><p><code>options</code>（可选）：对象，提供了一些附加选项，如 <code>capture</code>（布尔值，表示是否在捕获阶段移除事件监听器，默认为 false，即在冒泡阶段移除）和 <code>once</code>（布尔值，仅当 listener 是通过 <code>addEventLister()</code> 的 once 选项设置的监听器时才生效）。</p>
</li>
</ol>
<p>示例：</p>
<pre><code class="javascript">// 添加事件监听器
let button = document.getElementById(&quot;myButton&quot;);
let handleClick = function () &#123;
  console.log(&quot;Button clicked!&quot;);
&#125;;

button.addEventListener(&quot;click&quot;, handleClick);

// 移除事件监听器
button.removeEventListener(&quot;click&quot;, handleClick);
</code></pre>
<p>在上面的示例中，我们首先为一个按钮元素添加了一个点击事件监听器。然后，我们使用 <code>removeEventListener()</code> 方法移除了这个监听器，所以之后点击这个按钮将不会再触发 <code>handleClick</code> 函数。</p>
<h4 id="事件和方法提交"><a href="#事件和方法提交" class="headerlink" title="事件和方法提交"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/forms-submit">事件和方法提交</a></h4><ol>
<li><p><strong>表单提交事件</strong>:</p>
<ul>
<li><code>submit</code> 事件：当表单通过点击提交按钮或在表单元素上调用 <code>.submit()</code> 方法时触发。此事件可用于在提交前执行验证、清理或防止默认提交行为。</li>
</ul>
<pre><code class="javascript">document
  .getElementById(&quot;myForm&quot;)
  .addEventListener(&quot;submit&quot;, function (event) &#123;
    event.preventDefault(); // 阻止默认提交行为
    // 在此处进行表单验证或处理表单数据
  &#125;);
</code></pre>
</li>
<li><p><strong>表单提交方法</strong>:</p>
<ul>
<li><code>.submit()</code> 方法：用于提交表单数据到服务器。通常在验证成功后手动触发。</li>
</ul>
<pre><code class="javascript">var form = document.getElementById(&quot;myForm&quot;);
form.submit(); // 手动提交表单
</code></pre>
</li>
<li><p><strong>相关表单事件</strong>:</p>
<ul>
<li><code>input</code> 事件：当表单控件（如文本输入框、选择框等）的值发生变化时触发，用于实时监控和处理用户输入。</li>
<li><code>change</code> 事件：当表单控件的值发生变化且失去焦点后触发，主要用于单选按钮、复选框和选择框等。</li>
<li><code>focus</code> 和 <code>blur</code> 事件：分别在表单控件获取和失去焦点时触发，可用于提示信息或验证。</li>
</ul>
</li>
<li><p><strong>获取表单数据</strong>:</p>
<ul>
<li><code>form.elements</code>：返回表单中所有表单控件组成的 HTMLCollection，可以遍历这些元素并获取它们的值。</li>
<li><code>element.value</code>：获取单个表单控件的值，例如 <code>document.getElementById(&#39;username&#39;).value</code>。</li>
</ul>
</li>
<li><p><strong>表单验证</strong>:</p>
<ul>
<li>在提交事件处理程序中进行验证，可以使用正则表达式、内置校验 API（HTML5 支持）或自定义函数来检查表单数据的有效性。</li>
</ul>
</li>
</ol>
<p><strong>阻止表单提交默认事件</strong></p>
<p>在 JavaScript 中，阻止表单默认的提交事件通常是为了执行自定义的验证逻辑或异步提交操作。当表单提交时，如果不希望浏览器执行默认的提交行为（例如，重载页面或发送 HTTP POST 请求到 action 属性指定的 URL），可以通过调用事件对象的<code>preventDefault()</code>方法来阻止。</p>
<p>以下是一个示例：</p>
<pre><code class="html">&lt;form id=&quot;myForm&quot;&gt;
  &lt;!-- 表单控件 --&gt;
  &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
  document
    .getElementById(&quot;myForm&quot;)
    .addEventListener(&quot;submit&quot;, function (event) &#123;
      event.preventDefault(); // 阻止表单的默认提交行为

      // 在这里进行表单验证或其他自定义处理
      if (!validateForm()) &#123;
        alert(&quot;表单验证失败，请检查您的输入！&quot;);
        return;
      &#125;

      // 如果验证通过，可以执行异步提交或其他操作
      submitFormAsync();
    &#125;);

  // 示例验证函数
  function validateForm() &#123;
    // 实现具体的表单验证逻辑
    // 返回true表示验证通过，false表示验证失败
    return true;
  &#125;

  // 示例异步提交函数
  function submitFormAsync() &#123;
    // 使用Ajax或其他技术将表单数据发送到服务器
    // 这里仅为示意，实际项目中请替换为真实代码
  &#125;
&lt;/script&gt;
</code></pre>
<p>在这个示例中，当表单提交时，首先调用<code>event.preventDefault()</code>阻止默认提交行为。然后执行自定义的验证逻辑，如果验证失败则显示错误消息；如果验证通过，则调用<code>submitFormAsync</code>函数进行异步提交操作。这样既能保证表单数据的有效性，又能避免页面不必要的刷新或跳转。</p>
<h4 id="表单聚焦-x2F-失焦事件"><a href="#表单聚焦-x2F-失焦事件" class="headerlink" title="表单聚焦&#x2F;失焦事件"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/focus-blur">表单聚焦&#x2F;失焦事件</a></h4><p>在 HTML 表单中，有两个相关的事件用于处理元素聚焦和失焦的场景，分别是：</p>
<ol>
<li><p><code>focus</code> 事件：<br>当元素（如输入框、文本域、按钮等）获得焦点（用户开始对其进行操作，如点击或通过键盘 Tab 键切换到该元素）时触发。</p>
<pre><code class="javascript">document
  .getElementById(&quot;myInput&quot;)
  .addEventListener(&quot;focus&quot;, function (event) &#123;
    // 当元素获取焦点时执行的操作
    console.log(&quot;元素已获取焦点&quot;);
    // 可能会执行一些视觉变化，如高亮显示、清除提示信息等
  &#125;);
</code></pre>
</li>
<li><p><code>blur</code> 事件：<br>当元素失去焦点（用户离开该元素，如点击页面上的其他地方或通过键盘 Tab 键切换到其他元素）时触发。</p>
<pre><code class="javascript">document
  .getElementById(&quot;myInput&quot;)
  .addEventListener(&quot;blur&quot;, function (event) &#123;
    // 当元素失去焦点时执行的操作
    console.log(&quot;元素已失去焦点&quot;);
    // 可能会执行一些验证、保存临时数据、显示提示信息等操作
  &#125;);
</code></pre>
</li>
</ol>
<p>这两个事件常常搭配使用，例如在用户聚焦输入框时清除错误提示信息，在用户失焦时执行数据验证并重新显示可能存在的错误信息。</p>
<h4 id="输入事件"><a href="#输入事件" class="headerlink" title="输入事件"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/events-change-input">输入事件</a></h4><p>在 HTML 表单中，有几个与用户交互相关的事件，包括<code>change</code>、<code>input</code>、<code>cut</code>、<code>copy</code>和<code>paste</code>事件，它们分别对应不同的用户操作：</p>
<ol>
<li><p><strong>change</strong> 事件：</p>
<ul>
<li>当表单元素（如输入框、选择框、复选框等）的值发生改变且失去焦点时触发。通常用于一次性提交或验证用户更改后的表单值。</li>
</ul>
<pre><code class="javascript">document
  .getElementById(&quot;myInput&quot;)
  .addEventListener(&quot;change&quot;, function (event) &#123;
    let newValue = event.target.value;
    console.log(&quot;输入值已改变:&quot;, newValue);
    // 验证或处理新的表单值
  &#125;);
</code></pre>
</li>
<li><p><strong>input</strong> 事件：</p>
<ul>
<li>当表单元素的值发生改变时立即触发，无论元素是否失去焦点。对于实时反馈或即时验证非常有用。</li>
</ul>
<pre><code class="javascript">document
  .getElementById(&quot;myInput&quot;)
  .addEventListener(&quot;input&quot;, function (event) &#123;
    let currentValue = event.target.value;
    console.log(&quot;实时输入值:&quot;, currentValue);
    // 实时处理或验证输入值
  &#125;);
</code></pre>
</li>
<li><p><strong>cut</strong> 事件：</p>
<ul>
<li>当用户剪切（通过键盘快捷键 Ctrl+X 或右键菜单）表单元素（如文本输入框）中的内容时触发。</li>
</ul>
<pre><code class="javascript">document.getElementById(&quot;myInput&quot;).addEventListener(&quot;cut&quot;, function (event) &#123;
  console.log(&quot;内容已被剪切&quot;);
  // 处理剪切事件
&#125;);
</code></pre>
</li>
<li><p><strong>copy</strong> 事件：</p>
<ul>
<li>当用户复制（通过键盘快捷键 Ctrl+C 或右键菜单）表单元素中的内容时触发。</li>
</ul>
<pre><code class="javascript">document
  .getElementById(&quot;myInput&quot;)
  .addEventListener(&quot;copy&quot;, function (event) &#123;
    console.log(&quot;内容已被复制&quot;);
    // 处理复制事件，例如可以改变复制内容
    event.clipboardData.setData(&quot;text/plain&quot;, &quot;自定义复制的内容&quot;);
    event.preventDefault(); // 阻止默认复制行为，使用自定义内容
  &#125;);
</code></pre>
</li>
<li><p><strong>paste</strong> 事件：</p>
<ul>
<li>当用户粘贴（通过键盘快捷键 Ctrl+V 或右键菜单）内容到表单元素中时触发。</li>
</ul>
<pre><code class="javascript">document
  .getElementById(&quot;myInput&quot;)
  .addEventListener(&quot;paste&quot;, function (event) &#123;
    console.log(&quot;内容已被粘贴&quot;);
    // 处理粘贴事件，例如可以验证或修改粘贴内容
    let pastedContent = event.clipboardData.getData(&quot;text/plain&quot;);
    console.log(&quot;粘贴的内容是:&quot;, pastedContent);
    // 可以取消默认行为并自定义粘贴内容
    event.preventDefault();
    // ...
  &#125;);
</code></pre>
</li>
</ol>
<h4 id="表单属性和方法"><a href="#表单属性和方法" class="headerlink" title="表单属性和方法"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/form-elements">表单属性和方法</a></h4><p>在 HTML 中，表单（form）元素具有一系列属性和方法，这些属性和方法用于控制表单的提交、数据收集以及与其他元素的交互。以下是一些主要的表单属性和方法：</p>
<p><strong>表单属性：</strong></p>
<ol>
<li><p><strong>action</strong>：指定表单数据提交到的 URL 地址。</p>
<pre><code class="html">&lt;form action=&quot;/submit-form&quot; method=&quot;POST&quot;&gt;&lt;/form&gt;
</code></pre>
</li>
<li><p><strong>method</strong>：定义表单提交数据的方式，可选值包括<code>GET</code>和<code>POST</code>。</p>
<pre><code class="html">&lt;form action=&quot;/submit-form&quot; method=&quot;POST&quot;&gt;&lt;/form&gt;
</code></pre>
</li>
<li><p><strong>name</strong>：为表单赋予一个名字，以便在脚本中引用或在服务器端识别表单。</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;/submit-form&quot; method=&quot;POST&quot;&gt;&lt;/form&gt;
</code></pre>
</li>
<li><p><strong>target</strong>：规定在何处打开处理表单提交响应的资源。它可以是 <code>_blank</code>（新窗口&#x2F;标签页）、<code>_self</code>（当前窗口&#x2F;标签页）或其他 frame 或 iframe 的名字。</p>
<pre><code class="html">&lt;form action=&quot;/submit-form&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt;&lt;/form&gt;
</code></pre>
</li>
<li><p><strong>autocomplete</strong>：控制表单或表单字段是否启用自动完成功能。</p>
<pre><code class="html">&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; /&gt;
</code></pre>
</li>
<li><p><strong>enctype</strong>：定义表单数据提交时的编码方式，如 <code>application/x-www-form-urlencoded</code>（默认）、<code>multipart/form-data</code>（用于文件上传）或 <code>text/plain</code>。</p>
<pre><code class="html">&lt;form
  action=&quot;/upload-file&quot;
  method=&quot;POST&quot;
  enctype=&quot;multipart/form-data&quot;
&gt;&lt;/form&gt;
</code></pre>
</li>
</ol>
<p><strong>表单方法（JavaScript DOM 操作）：</strong></p>
<ol>
<li><p>**.submit()**：提交表单。</p>
<pre><code class="javascript">document.getElementById(&quot;myForm&quot;).submit();
</code></pre>
</li>
<li><p>**.reset()**：重置表单的所有字段至初始状态。</p>
<pre><code class="javascript">document.getElementById(&quot;myForm&quot;).reset();
</code></pre>
</li>
<li><p><strong>elements</strong>：返回一个 HTMLFormControlsCollection 对象，包含了表单内的所有表单控件。</p>
<pre><code class="javascript">let formData = document.forms[&quot;myForm&quot;].elements;
</code></pre>
</li>
<li><p>**checkValidity()**：检查表单是否满足所有必要的验证要求，返回布尔值。</p>
<pre><code class="javascript">let isValid = document.getElementById(&quot;myForm&quot;).checkValidity();
</code></pre>
</li>
<li><p>**reportValidity()**：检查表单的验证状态并在必要时显示浏览器的原生验证提示。</p>
<pre><code class="javascript">document.getElementById(&quot;myForm&quot;).reportValidity();
</code></pre>
</li>
<li><p>**requestSubmit()**：提交表单，同时触发提交和相关提交事件。</p>
<pre><code class="javascript">document.getElementById(&quot;myForm&quot;).requestSubmit();
</code></pre>
</li>
</ol>
<h4 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Form_validation#%E4%BD%BF%E7%94%A8_javascript%E6%A0%A1%E9%AA%8C%E8%A1%A8%E5%8D%95">表单验证</a></h4><p>表单验证是指在网页表单提交之前，对用户输入的数据进行有效性检查的过程。表单验证可以在客户端（前端）和服务器端（后端）进行，以确保数据符合预期格式和业务规则，提高数据质量，减少因非法数据导致的问题。</p>
<p><strong>前端（客户端）验证</strong>：<br>前端验证可以在用户提交表单前即时反馈错误信息，提升用户体验。常用的前端验证手段包括：</p>
<ol>
<li><p><strong>HTML5 内置验证</strong>：</p>
<ul>
<li>使用 HTML5 提供的属性，如<code>required</code>（必填项）、<code>pattern</code>（匹配正则表达式）、<code>minlength</code>、<code>maxlength</code>（限制字符长度）、<code>type</code>（如 email、url 等）。</li>
</ul>
<pre><code class="html">&lt;input type=&quot;email&quot; required placeholder=&quot;请输入邮箱&quot; /&gt;
</code></pre>
</li>
<li><p><strong>JavaScript 验证</strong>：</p>
<ul>
<li>使用 JavaScript 编写自定义验证函数，监听表单事件（如<code>submit</code>、<code>blur</code>、<code>input</code>等），并进行数据验证。</li>
</ul>
<pre><code class="javascript">document
  .getElementById(&quot;myForm&quot;)
  .addEventListener(&quot;submit&quot;, function (event) &#123;
    const email = document.getElementById(&quot;email&quot;);
    if (!isValidEmail(email.value)) &#123;
      alert(&quot;请输入有效的邮箱地址&quot;);
      event.preventDefault(); // 阻止表单提交
    &#125;
  &#125;);
</code></pre>
</li>
</ol>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2024/05/10/Swiper11%E5%9C%A8Vue2%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"
      title="Swiper11在Vue2项目中的使用"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        Swiper11在Vue2项目中的使用
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/04/13/%E5%9F%BA%E4%BA%8EVue2%E7%9A%84%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"
      title="Vue2开发学习笔记"
     >

    <p class="title-text">
      
        Vue2开发学习笔记
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>




  <script src="https://cdn.staticfile.org/twikoo/1.6.21/twikoo.all.min.js"></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">Comments </div>
    </div>
    <div id="tcomment"></div>
  </div>
  <script>
      twikoo.init({
          envId: 'https://yunsheng-blog-comments.site',
          el: '#tcomment',
          region: '',
          path: 'location.pathname',
          lang: '',
      })
  </script>
  
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 云升<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
